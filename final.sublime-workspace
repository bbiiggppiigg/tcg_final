{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"object",
				"objects"
			],
			[
				"cours",
				"course_map"
			],
			[
				"reade",
				"readfile"
			],
			[
				"course",
				"course_id_set"
			],
			[
				"read",
				"readfile"
			],
			[
				"objec",
				"object_id"
			],
			[
				"obj",
				"object_val"
			],
			[
				"cour",
				"course_id"
			],
			[
				"tmp",
				"tmp_index"
			],
			[
				"next",
				"next_y"
			],
			[
				"eat",
				"eat_flag"
			],
			[
				"ea",
				"eat_flag"
			],
			[
				"che",
				"check_flag"
			],
			[
				"check",
				"check_flag"
			],
			[
				"chec",
				"check_flag"
			],
			[
				"ne",
				"neighbor_state"
			],
			[
				"li",
				"liberties"
			],
			[
				"Libert",
				"liberties"
			],
			[
				"else",
				"else_content"
			],
			[
				"num",
				"num_bound"
			],
			[
				"nex",
				"next_y"
			],
			[
				"upte",
				"update_count"
			],
			[
				"update",
				"update_count"
			],
			[
				"find",
				"find_liberty"
			],
			[
				"nu",
				"num_bound"
			],
			[
				"count",
				"count_neighborhood_state"
			],
			[
				"gtp",
				"gtp_showboard"
			],
			[
				"print",
				"print_count"
			],
			[
				"itera",
				"iteration_count"
			],
			[
				"win",
				"winCount"
			],
			[
				"play",
				"play_to_end"
			],
			[
				"game",
				"game_length"
			],
			[
				"Gam",
				"GameRecord"
			],
			[
				"MOv",
				"MoveList"
			],
			[
				"Bi",
				"BOARDSIZE"
			],
			[
				"Ga",
				"GameRecord"
			],
			[
				"gam",
				"game_length"
			],
			[
				"cur",
				"currentMax"
			],
			[
				"Mov",
				"MoveList"
			],
			[
				"mov",
				"move_id"
			],
			[
				"Win",
				"winCount"
			],
			[
				"Bo",
				"Board"
			],
			[
				"Boun",
				"BOUNDARYSIZE"
			],
			[
				"time",
				"time_limit"
			],
			[
				"end",
				"end_t"
			],
			[
				"BOun",
				"BOUNDARYSIZE"
			],
			[
				"Con",
				"ConnectBoard"
			],
			[
				"const",
				"constant"
			],
			[
				"Di",
				"DirectionY"
			],
			[
				"lab",
				"lambda"
			],
			[
				"s",
				"sqrt"
			],
			[
				"la",
				"lambda"
			],
			[
				"lam",
				"lambda"
			],
			[
				"lamb",
				"lambda2"
			],
			[
				"labd",
				"lambda1"
			],
			[
				"lb",
				"lambda2"
			],
			[
				"wg",
				"wreg1"
			],
			[
				"wreg",
				"wreg1"
			],
			[
				"Eval",
				"Eval_history"
			],
			[
				"X",
				"Xvalid"
			],
			[
				"Eva",
				"Eval_histroy"
			],
			[
				"min",
				"min_index"
			],
			[
				"Eout",
				"Eout_history"
			],
			[
				"wh",
				"w_history"
			],
			[
				"w",
				"w_history"
			],
			[
				"Ein",
				"Ein_history"
			],
			[
				"eror",
				"error_history"
			],
			[
				"err",
				"error_history"
			],
			[
				"ra",
				"random_index"
			],
			[
				"gra",
				"gradient"
			],
			[
				"eive",
				"eigenvalue"
			],
			[
				"eiv",
				"eigenvalues"
			],
			[
				"eig",
				"eigenvector"
			],
			[
				"e",
				"eigenvector"
			],
			[
				"best",
				"best_index"
			],
			[
				"error",
				"error_sum2"
			],
			[
				"erro",
				"error_sum1"
			],
			[
				"er",
				"error_sum2"
			],
			[
				"ero",
				"error_sum1"
			],
			[
				"in",
				"inchage"
			],
			[
				"h",
				"hypothesis"
			],
			[
				"ref",
				"ref_count"
			],
			[
				"clo",
				"close_list"
			],
			[
				"pi",
				"piindex"
			],
			[
				"swa",
				"swap_index_tile_id"
			],
			[
				"TO",
				"TOTAL-1"
			],
			[
				"PAT",
				"PATTERN_SIZE"
			],
			[
				"inpu",
				"input_db"
			],
			[
				"T",
				"TOTAL"
			],
			[
				"input",
				"input_file_name"
			],
			[
				"init",
				"init_with_sequence"
			],
			[
				"PA",
				"PATTERN_SIZE"
			],
			[
				"state",
				"state_size"
			],
			[
				"swap_in",
				"swap_index_tile_id"
			],
			[
				"tile",
				"tile_id"
			],
			[
				"sw",
				"swap_index_tile_id"
			],
			[
				"til",
				"tile_id"
			],
			[
				"step",
				"step_size"
			],
			[
				"ope",
				"open_list"
			],
			[
				"op",
				"open_list"
			],
			[
				"dir",
				"direc"
			],
			[
				"gen",
				"gen_board"
			],
			[
				"init_seq",
				"init_sequence"
			],
			[
				"mem",
				"memset"
			],
			[
				"no",
				"no_re"
			],
			[
				"c",
				"class	class-..-(class)"
			],
			[
				"log",
				"logstring"
			],
			[
				"FIL",
				"FILENAME"
			],
			[
				"last",
				"last_move"
			],
			[
				"is",
				"is_goal"
			],
			[
				"tescase",
				"testcases"
			],
			[
				"testcase",
				"testcases"
			],
			[
				"test",
				"testcases"
			],
			[
				"File",
				"filename"
			],
			[
				"tab",
				"lookup_table"
			],
			[
				"TA",
				"TOTAL"
			],
			[
				"hva_to",
				"hva_to_pfn"
			],
			[
				"vm",
				"vma"
			],
			[
				"empt",
				"empty_index"
			],
			[
				"emp",
				"empty_index"
			],
			[
				"memso",
				"memslot"
			],
			[
				"fault",
				"fault_ipa"
			],
			[
				"kvm_vcpu_dabt_get",
				"kvm_vcpu_dabt_get_as"
			],
			[
				"Phyi",
				"physical"
			],
			[
				"kvm_vcpu_get",
				"kvm_vcpu_get_hfar"
			],
			[
				"FSC",
				"FSC_FAULT"
			],
			[
				"pock",
				"plocket_pla"
			],
			[
				"po",
				"plocket_pla"
			]
		]
	},
	"buffers":
	[
	],
	"build_system": "",
	"command_palette":
	{
		"height": 207.0,
		"selected_items":
		[
			[
				"la",
				"LaTeXTools: Reconfigure and migrate settings"
			],
			[
				"Package Control: ins",
				"Package Control: Install Package"
			],
			[
				"package control : int",
				"Package Control: Install Package"
			],
			[
				"package control : Insta",
				"Package Control: Install Package"
			],
			[
				"latex",
				"LaTeXTools: View PDF"
			],
			[
				"install",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 188.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/bbiiggppiigg/Desktop/tcg_2015_final_project/final_project_template/anqi.cc",
		"/Users/bbiiggppiigg/Desktop/10912.cpp",
		"/Users/bbiiggppiigg/Desktop/Tracing",
		"/Users/bbiiggppiigg/Desktop/Part1+Part2/linux-2.6.32.60/kernel/sched_sjf copy.c",
		"/Users/bbiiggppiigg/Desktop/untitled.py",
		"/Users/bbiiggppiigg/parse.sh",
		"/Users/bbiiggppiigg/Desktop/source/scripts/extract_feature22.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/parse_object_tree.cpp",
		"/Users/bbiiggppiigg/Desktop/source/object_tree.csv",
		"/Users/bbiiggppiigg/Desktop/source/newdata/object_id_map.txt",
		"/Users/bbiiggppiigg/Desktop/source/scripts/build_course_id_map.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/build_user_id_map.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/compress_relation.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/build_object_id_map.py",
		"/Users/bbiiggppiigg/Desktop/source/compressed_enrollment.csv",
		"/Users/bbiiggppiigg/Desktop/source/scripts/compress_log.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/course_id_map.txt",
		"/Users/bbiiggppiigg/Desktop/source/scripts/user_id_map.txt",
		"/Users/bbiiggppiigg/Desktop/source/scripts/compress_enrollment.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/compress_object.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/compress_enrollment.csv",
		"/Users/bbiiggppiigg/Desktop/source/compressed_object.csv",
		"/Users/bbiiggppiigg/Desktop/source/scripts/update_object.py",
		"/Users/bbiiggppiigg/Desktop/source/tmp_object.csv",
		"/Users/bbiiggppiigg/Desktop/source/scripts/replace_object_id_in_tmp_object.py",
		"/Users/bbiiggppiigg/Desktop/source/scripts/object_id_map.txt",
		"/Users/bbiiggppiigg/Desktop/source/scripts/split_child.py",
		"/Users/bbiiggppiigg/Desktop/source/compress_object.py",
		"/Users/bbiiggppiigg/Desktop/final/ML_final_project/scripts/save_split_object.py",
		"/Users/bbiiggppiigg/Desktop/final/ML_final_project/scripts/count_tf_idf.py",
		"/Users/bbiiggppiigg/Desktop/final/ML_final_project/scripts/split_object.py",
		"/Users/bbiiggppiigg/Desktop/final/ML_final_project/output/0.csv",
		"/Users/bbiiggppiigg/Desktop/final/ML_final_project/scripts/create_enroll_tables.py",
		"/Users/bbiiggppiigg/Desktop/cghw2/code2/UCTRPPGameTree.h",
		"/Users/bbiiggppiigg/Desktop/cghw2/code2/UCTRPPGameTree.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/code2/report.md",
		"/Users/bbiiggppiigg/Desktop/cghw2/code2/GoBoard.cpp",
		"/Users/bbiiggppiigg/Desktop/fuseki.txt",
		"/Users/bbiiggppiigg/Desktop/123.c",
		"/Users/bbiiggppiigg/mlhw6/m14.m",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/gen_neighbor_bitmask.c",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/out",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/GoBoard.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/pure_random.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/randomgo99.cpp",
		"/Users/bbiiggppiigg/Desktop/11:30進度報告",
		"/Users/bbiiggppiigg/Desktop/11:15進度報告.txt",
		"/Users/bbiiggppiigg/Desktop/cghw2/gogui-1.4.9/bin/start.sh",
		"/Users/bbiiggppiigg/Desktop/cghw2/gogui-1.4.9/bin/log.txt",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/Makefile",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/version1.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/codes/hw2_2.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/gogui-1.4.9/config/gogui.schemas",
		"/Users/bbiiggppiigg/test/123.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/version1.cpp",
		"/Users/bbiiggppiigg/Desktop/cghw2/Makefile",
		"/Users/bbiiggppiigg/mlhw4/MLHW4.docx",
		"/Users/bbiiggppiigg/Desktop/cghw2/gogui-1.4.9/src/net/sf/gogui/gtp/GtpClient.java",
		"/Users/bbiiggppiigg/mlhw4/hw4_written.m",
		"/Users/bbiiggppiigg/mlhw4/q20.m",
		"/Users/bbiiggppiigg/mlhw4/extend.m",
		"/Users/bbiiggppiigg/mlhw4/q19.m",
		"/Users/bbiiggppiigg/mlhw4/q18.m",
		"/Users/bbiiggppiigg/mlhw4/q17.m",
		"/Users/bbiiggppiigg/mlhw4/q9.m",
		"/Users/bbiiggppiigg/mlhw4/q16.m",
		"/Users/bbiiggppiigg/mlhw4/q13.m",
		"/Users/bbiiggppiigg/mlhw4/q15.m",
		"/Users/bbiiggppiigg/mlhw4/q14.m",
		"/Users/bbiiggppiigg/mlhw4/count_error.m",
		"/Users/bbiiggppiigg/mlhw4/validate.m",
		"/Users/bbiiggppiigg/test/mykernel.cl",
		"/Users/bbiiggppiigg/test/square.c",
		"/Users/bbiiggppiigg/test/compile.sh",
		"/Users/bbiiggppiigg/test/test.cl",
		"/Users/bbiiggppiigg/test/test.c",
		"/Users/bbiiggppiigg/test/Makefile",
		"/Users/bbiiggppiigg/mlhw3/q6.m",
		"/Users/bbiiggppiigg/mlhw3/q18.m",
		"/Users/bbiiggppiigg/mlhw3/q14.m",
		"/Users/bbiiggppiigg/mlhw3/q15.m",
		"/Users/bbiiggppiigg/mlhw3/q13.m",
		"/Users/bbiiggppiigg/mlhw3/q11.m",
		"/Users/bbiiggppiigg/mlhw3/written",
		"/Users/bbiiggppiigg/mlhw3/tttt.m",
		"/Users/bbiiggppiigg/mlhw3/q20.m",
		"/Users/bbiiggppiigg/mlhw3/q19.m",
		"/Users/bbiiggppiigg/mlhw3/q18_5.m",
		"/Users/bbiiggppiigg/mlhw3/q10.m",
		"/Users/bbiiggppiigg/mlhw3/q7.m",
		"/Users/bbiiggppiigg/Desktop/電腦對局理論期中考2015",
		"/Users/bbiiggppiigg/Desktop/懷疑論期中考",
		"/Users/bbiiggppiigg/Desktop/無限恐怖/024.txt",
		"/Users/bbiiggppiigg/Desktop/無限恐怖/025.txt",
		"/Users/bbiiggppiigg/Desktop/無限恐怖/023.txt",
		"/Users/bbiiggppiigg/Desktop/rtshw1/rts_pj1.tex",
		"/Users/bbiiggppiigg/Desktop/rtshw1/update.txt",
		"/Users/bbiiggppiigg/Desktop/無限恐怖/022.txt",
		"/Users/bbiiggppiigg/Desktop/Biweekly Report 11:1",
		"/Users/bbiiggppiigg/Desktop/rtshw1report.tex",
		"/Users/bbiiggppiigg/Desktop/rtshw1report.aux",
		"/Users/bbiiggppiigg/Desktop/test.text",
		"/Users/bbiiggppiigg/mlh2/20/q20.m",
		"/Users/bbiiggppiigg/mlh2/q11.m",
		"/Users/bbiiggppiigg/mlh2/q3.m",
		"/Users/bbiiggppiigg/ntu-homeworks-master/2013-fall-MachineLearning/hw2/hw2_17.py",
		"/Users/bbiiggppiigg/mlh2/q20.m",
		"/Users/bbiiggppiigg/mlh2/q19.m",
		"/Users/bbiiggppiigg/mlh2/hw2.txt",
		"/Users/bbiiggppiigg/mlh2/q4.m",
		"/Users/bbiiggppiigg/mlh2/q5.m",
		"/Users/bbiiggppiigg/mlh2/q17.m",
		"/Users/bbiiggppiigg/ntu-homeworks-master/2013-fall-MachineLearning/hw2/hw2_18.py",
		"/Users/bbiiggppiigg/ntu-homeworks-master/2013-fall-MachineLearning/hw2/dsa.py",
		"/Users/bbiiggppiigg/CG/hw1/5x5/Makefile",
		"/Users/bbiiggppiigg/CG/hw1/5x5/run.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_run.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/log/runlog",
		"/Users/bbiiggppiigg/CG/hw1/4x4/testcase/test.in",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_run_sub.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/Makefile",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_run_sub_fh.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_run_sub_sh.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_run_sub_stack.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_db_sub.cpp",
		"/Users/bbiiggppiigg/CG/hw1/.gitignore",
		"/Users/bbiiggppiigg/CG/hw1/5x5/new_db.cpp",
		"/Users/bbiiggppiigg/CG/hw1/4x4/new_db.cpp"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"",
			"<textarea name=\"comments\">Enter text here.</textarea>",
			" <textarea rows=\"1\" cols=\"25\" name=\"answer1\"></textarea>",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"__y",
			"sjf",
			"3fpwAdewUyNZkLToSwy7eWQmmglHzA0G",
			"next_turn",
			"win_counter_square",
			"union",
			"update_count",
			"for_each_tile",
			"for_each_neighbor",
			"liberties",
			"count_nei",
			"gen_legal_move",
			"count_neigh",
			"update_board",
			"pick_move",
			"record",
			"GameRecord",
			"gen_legal_move",
			"do_move",
			"cerr",
			"play_to_end",
			"game_length",
			"BLACK",
			"genmove",
			"play_to_end",
			"genmove",
			"genm",
			"gen",
			"/*\n * This code is provied as a sample code of Hw 2 of \"Theory of Computer Game\".\n * The \"genmove\" function will randomly output one of the legal move.\n * This code can only be used within the class.\n *\n * 2015 Nov. Hung-Jui Chang\n * */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n\n#define BOARDSIZE        9\n#define BOUNDARYSIZE    11\n#define COMMANDLENGTH 1000\n#define DEFAULTTIME     10\n#define DEFAULTKOMI      7\n\n#define MAXGAMELENGTH 1000\n#define MAXSTRING       50\n#define MAXDIRECTION     4\n\n#define NUMINTERSECTION 81\n#define HISTORYLENGTH   200\n\n#define EMPTY            0\n#define BLACK            1\n#define WHITE            2\n#define BOUNDARY         3\n\n#define SELF             1\n#define OPPONENT         2\n\n#define NUMGTPCOMMANDS      15\n\n#define LOCALVERSION      1\n#define GTPVERSION        2\n \nusing namespace std;\nint _board_size = BOARDSIZE;\nint _board_boundary = BOUNDARYSIZE;\ndouble _komi =  DEFAULTKOMI;\nconst int DirectionX[MAXDIRECTION] = {-1, 0, 1, 0};\nconst int DirectionY[MAXDIRECTION] = { 0, 1, 0,-1};\nconst char LabelX[]=\"0ABCDEFGHJ\";\n\n\n/*\n * This function reset the board, the board intersections are labeled with 0,\n * the boundary intersections are labeled with 3.\n * */\nvoid reset(int Board[BOUNDARYSIZE][BOUNDARYSIZE]) {\n    for (int i = 1 ; i <= BOARDSIZE; ++i) {\n	for (int j = 1 ; j <= BOARDSIZE; ++j) {\n	    Board[i][j] = EMPTY;\n	}\n    }\n    for (int i = 0 ; i < BOUNDARYSIZE; ++i) {\n	Board[0][i] = Board[BOUNDARYSIZE-1][i] = Board[i][0] = Board[i][BOUNDARYSIZE-1] = BOUNDARY;\n    }\n}\n\n/*\n * This function return the total number of liberity of the string of (X, Y) and\n * the string will be label with 'label'.\n * */\nint find_liberty(int X, int Y, int label, int Board[BOUNDARYSIZE][BOUNDARYSIZE], int ConnectBoard[BOUNDARYSIZE][BOUNDARYSIZE]) {\n    // Label the current intersection\n    ConnectBoard[X][Y] |= label;\n    int total_liberty = 0;\n    for (int d = 0 ; d < MAXDIRECTION; ++d) {\n	// Check this intersection has been visited or not\n	if ((ConnectBoard[X+DirectionX[d]][Y+DirectionY[d]] & (1<<label) )!= 0) continue;\n\n	// Check this intersection is not visited yet\n	ConnectBoard[X+DirectionX[d]][Y+DirectionY[d]] |=(1<<label);\n	// This neighboorhood is empty\n	if (Board[X+DirectionX[d]][Y+DirectionY[d]] == EMPTY){\n	    total_liberty++;\n	}\n	// This neighboorhood is self stone\n	else if (Board[X+DirectionX[d]][Y+DirectionY[d]] == Board[X][Y]) {\n	    total_liberty += find_liberty(X+DirectionX[d], Y+DirectionY[d], label, Board, ConnectBoard);\n	}\n    }\n    return total_liberty;\n}\n\n/*\n * This function count the liberties of the given intersection's neighboorhod\n * */\nvoid count_liberty(int X, int Y, int Board[BOUNDARYSIZE][BOUNDARYSIZE], int Liberties[MAXDIRECTION]) {\n    int ConnectBoard[BOUNDARYSIZE][BOUNDARYSIZE];\n    // Initial the ConnectBoard\n    for (int i = 0 ; i < BOUNDARYSIZE; ++i) {\n	for (int j = 0 ; j < BOUNDARYSIZE; ++j) {\n	    ConnectBoard[i][j] = 0;\n	}\n    }\n    // Find the same connect component and its liberity\n    for (int d = 0 ; d < MAXDIRECTION; ++d) {\n	Liberties[d] = 0;\n	if (Board[X+DirectionX[d]][Y+DirectionY[d]] == BLACK ||  \n	    Board[X+DirectionX[d]][Y+DirectionY[d]] == WHITE    ) {\n	    Liberties[d] = find_liberty(X+DirectionX[d], Y+DirectionY[d], d, Board, ConnectBoard);\n	}\n    }\n}\n\n/*\n * This function count the number of empty, self, opponent, and boundary intersections of the neighboorhod\n * and saves the type in NeighboorhoodState.\n * */\nvoid count_neighboorhood_state(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int X, int Y, int turn, int* empt, int* self, int* oppo ,int* boun, int NeighboorhoodState[MAXDIRECTION]) {\n    for (int d = 0 ; d < MAXDIRECTION; ++d) {\n	// check the number of nonempty neighbor\n	switch(Board[X+DirectionX[d]][Y+DirectionY[d]]) {\n	    case EMPTY:    (*empt)++; \n			   NeighboorhoodState[d] = EMPTY;\n			   break;\n	    case BLACK:    if (turn == BLACK) {\n			       (*self)++;\n			       NeighboorhoodState[d] = SELF;\n			   }\n			   else {\n			       (*oppo)++;\n			       NeighboorhoodState[d] = OPPONENT;\n			   }\n			   break;\n	    case WHITE:    if (turn == WHITE) {\n			       (*self)++;\n			       NeighboorhoodState[d] = SELF;\n			   }\n			   else {\n			       (*oppo)++;\n			       NeighboorhoodState[d] = OPPONENT;\n			   }\n			   break;\n	    case BOUNDARY: (*boun)++;\n			   NeighboorhoodState[d] = BOUNDARY;\n			   break;\n	}\n    }\n}\n\n/*\n * This function remove the connect component contains (X, Y) with color \"turn\" \n * And return the number of remove stones.\n * */\nint remove_piece(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int X, int Y, int turn) {\n    int remove_stones = (Board[X][Y]==EMPTY)?0:1;\n    Board[X][Y] = EMPTY;\n    for (int d = 0; d < MAXDIRECTION; ++d) {\n	if (Board[X+DirectionX[d]][Y+DirectionY[d]] == turn) {\n	    remove_stones += remove_piece(Board, X+DirectionX[d], Y+DirectionY[d], turn);\n	}\n    }\n    return remove_stones;\n}\n/*\n * This function update Board with place turn's piece at (X,Y).\n * Note that this function will not check if (X, Y) is a legal move or not.\n * */\nvoid update_board(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int X, int Y, int turn) {\n    int num_neighborhood_self = 0;\n    int num_neighborhood_oppo = 0;\n    int num_neighborhood_empt = 0;\n    int num_neighborhood_boun = 0;\n    int Liberties[4];\n    int NeighboorhoodState[4];\n    count_neighboorhood_state(Board, X, Y, turn,\n	    &num_neighborhood_empt,\n	    &num_neighborhood_self,\n	    &num_neighborhood_oppo,\n	    &num_neighborhood_boun, NeighboorhoodState);\n    // check if there is opponent piece in the neighboorhood\n    if (num_neighborhood_oppo != 0) {\n	count_liberty(X, Y, Board, Liberties);\n	for (int d = 0 ; d < MAXDIRECTION; ++d) {\n	    // check if there is opponent component only one liberty\n	    if (NeighboorhoodState[d] == OPPONENT && Liberties[d] == 1 && Board[X+DirectionX[d]][Y+DirectionY[d]]!=EMPTY) {\n		remove_piece(Board, X+DirectionX[d], Y+DirectionY[d], Board[X+DirectionX[d]][Y+DirectionY[d]]);\n	    }\n	}\n    }\n    Board[X][Y] = turn;\n}\n/*\n * This function update Board with place turn's piece at (X,Y).\n * Note that this function will check if (X, Y) is a legal move or not.\n * */\nint update_board_check(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int X, int Y, int turn) {\n    // Check the given coordination is legal or not\n    if ( X < 1 || X > BOARDSIZE || Y < 1 || Y > BOARDSIZE || Board[X][Y]!=EMPTY)\n	return 0;\n    int num_neighborhood_self = 0;\n    int num_neighborhood_oppo = 0;\n    int num_neighborhood_empt = 0;\n    int num_neighborhood_boun = 0;\n    int Liberties[4];\n    int NeighboorhoodState[4];\n    count_neighboorhood_state(Board, X, Y, turn,\n	    &num_neighborhood_empt,\n	    &num_neighborhood_self,\n	    &num_neighborhood_oppo,\n	    &num_neighborhood_boun, NeighboorhoodState);\n    // Check if the move is a legal move\n    // Condition 1: there is a empty intersection in the neighboorhood\n    int legal_flag = 0;\n    count_liberty(X, Y, Board, Liberties);\n    if (num_neighborhood_empt != 0) {\n	legal_flag = 1;\n    }\n    else {\n	// Condition 2: there is a self string has more than one liberty\n	for (int d = 0; d < MAXDIRECTION; ++d) {\n	    if (NeighboorhoodState[d] == SELF && Liberties[d] > 1) {\n		legal_flag = 1;\n	    }\n	}\n	if (legal_flag == 0) {\n	// Condition 3: there is a opponent string has exactly one liberty\n	    for (int d = 0; d < MAXDIRECTION; ++d) {\n		if (NeighboorhoodState[d] == OPPONENT && Liberties[d] == 1) {\n		    legal_flag = 1;\n		}\n	    }\n	}\n    }\n\n    if (legal_flag == 1) {\n    // check if there is opponent piece in the neighboorhood\n	if (num_neighborhood_oppo != 0) {\n	    for (int d = 0 ; d < MAXDIRECTION; ++d) {\n		// check if there is opponent component only one liberty\n		if (NeighboorhoodState[d] == OPPONENT && Liberties[d] == 1 && Board[X+DirectionX[d]][Y+DirectionY[d]]!=EMPTY) {\n		    remove_piece(Board, X+DirectionX[d], Y+DirectionY[d], Board[X+DirectionX[d]][Y+DirectionY[d]]);\n		}\n	    }\n	}\n	Board[X][Y] = turn;\n    }\n\n    return (legal_flag==1)?1:0;\n}\n\n/*\n * This function return the number of legal moves with clor \"turn\" and\n * saves all legal moves in MoveList\n * */\nint gen_legal_move(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int turn, int game_length, int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE], int MoveList[HISTORYLENGTH]) {\n    int NextBoard[BOUNDARYSIZE][BOUNDARYSIZE];\n    int num_neighborhood_self = 0;\n    int num_neighborhood_oppo = 0;\n    int num_neighborhood_empt = 0;\n    int num_neighborhood_boun = 0;\n    int legal_moves = 0;\n    int next_x, next_y;\n    int Liberties[4];\n    int NeighboorhoodState[4];\n    bool eat_move = 0;\n    for (int x = 1 ; x <= BOARDSIZE; ++x) {\n	for (int y = 1 ; y <= BOARDSIZE; ++y) {\n	    // check if current \n	    if (Board[x][y] == 0) {\n		// check the liberty of the neighborhood intersections\n		num_neighborhood_self = 0;\n		num_neighborhood_oppo = 0;\n		num_neighborhood_empt = 0;\n		num_neighborhood_boun = 0;\n		// count the number of empy, self, opponent, and boundary neighboorhood\n		count_neighboorhood_state(Board, x, y, turn,\n			&num_neighborhood_empt,\n			&num_neighborhood_self,\n			&num_neighborhood_oppo,\n			&num_neighborhood_boun, NeighboorhoodState);\n		// check if the emtpy intersection is a legal move\n		next_x = next_y = 0;\n		eat_move = 0;\n		count_liberty(x, y, Board, Liberties);\n		// Case 1: exist empty intersection in the neighborhood\n		 if (num_neighborhood_empt > 0) {\n		     next_x = x;\n		     next_y = y;\n		     // check if it is a capture move\n		     for (int d = 0 ; d < MAXDIRECTION; ++d) {\n			 if (NeighboorhoodState[d] == OPPONENT && Liberties[d] == 1) {\n			     eat_move = 1;\n			 }\n		     }\n\n		 }\n		 // Case 2: no empty intersection in the neighborhood\n		 else {\n		    // Case 2.1: Surround by the self piece\n		    if (num_neighborhood_self + num_neighborhood_boun == MAXDIRECTION) {\n			int check_flag = 0, check_eye_flag = num_neighborhood_boun;\n			for (int d = 0 ; d < MAXDIRECTION; ++d) {\n			    // Avoid fill self eye\n			    if (NeighboorhoodState[d]==SELF && Liberties[d] > 1) {\n				check_eye_flag++;\n			    }\n			    // Check if there is one self component which has more than one liberty\n			    if (NeighboorhoodState[d]==SELF && Liberties[d] > 1) {\n				check_flag = 1;\n			    }\n			}\n			if (check_flag == 1 && check_eye_flag!=4) {\n			    next_x = x;\n			    next_y = y;\n			}\n		    }	\n		    // Case 2.2: Surround by opponent or both side's pieces.\n		    else if (num_neighborhood_oppo > 0) {\n			int check_flag = 0;\n			int eat_flag = 0;\n			for (int d = 0 ; d < MAXDIRECTION; ++d) {\n			    // Check if there is one self component which has more than one liberty\n			    if (NeighboorhoodState[d]==SELF && Liberties[d] > 1) {\n				check_flag = 1;\n			    }\n			    // Check if there is one opponent's component which has exact one liberty\n			    if (NeighboorhoodState[d]==OPPONENT && Liberties[d] == 1) {\n				eat_flag = 1;\n			    }\n			}\n			if (check_flag == 1) {\n			    next_x = x;\n			    next_y = y;\n			    if (eat_flag == 1) {\n				eat_move = 1;\n			    }\n			}\n			else { // check_flag == 0\n			    if (eat_flag == 1) {\n				next_x = x;\n				next_y = y;\n				eat_move = 1;\n			    }\n			}\n		    }	\n		 }\n		 if (next_x !=0 && next_y !=0) {\n		 // copy the current board to next board\n		    for (int i = 0 ; i < BOUNDARYSIZE; ++i) {\n			for (int j = 0 ; j < BOUNDARYSIZE; ++j) {\n			    NextBoard[i][j] = Board[i][j];\n			}\n		    }\n		    // do the move\n		    // The move is a capture move and the board needs to be updated.\n		    if (eat_move == 1) {\n			update_board(NextBoard, next_x, next_y, turn);\n		    }\n		    else {\n			NextBoard[x][y] = turn;\n		    }\n		    // Check the history to avoid the repeat board\n		    bool repeat_move = 0;\n		    for (int t = 0 ; t < game_length; ++t) {\n			bool repeat_flag = 1;\n			for (int i = 1; i <=BOARDSIZE; ++i) {\n			    for (int j = 1; j <=BOARDSIZE; ++j) {\n				if (NextBoard[i][j] != GameRecord[t][i][j]) {\n				    repeat_flag = 0;\n				}\n			    }\n			}\n			if (repeat_flag == 1) {\n			    repeat_move = 1;\n			    break;\n			}\n		    }\n		    if (repeat_move == 0) {\n			// 3 digit zxy, z means eat or not, and put at (x, y)\n			MoveList[legal_moves] = eat_move * 100 + next_x * 10 + y ;\n			legal_moves++;\n		    }\n		 }\n	    }\n	}\n    }\n    return legal_moves;\n}\n/*\n * This function randomly selects one move from the MoveList.\n * */\nint rand_pick_move(int num_legal_moves, int MoveList[HISTORYLENGTH]) {\n    if (num_legal_moves == 0)\n	return 0;\n    else {\n	int move_id = rand()%num_legal_moves;\n	return MoveList[move_id];\n    }\n}\n/*\n * This function update the Board with put 'turn' at (x,y)\n * where x = (move % 100) / 10 and y = move % 10.\n * Note this function will not check 'move' is legal or not.\n * */\nvoid do_move(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int turn, int move) {\n    int move_x = (move % 100) / 10;\n    int move_y = move % 10;\n    if (move<100) {\n	Board[move_x][move_y] = turn;\n    }\n    else {\n	update_board(Board, move_x, move_y, turn);\n    }\n\n}\n/* \n * This function records the current game baord with current\n * game length \"game_length\"\n * */\nvoid record(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE], int game_length) {\n		for (int i = 0 ; i < BOUNDARYSIZE; ++i) {\n		    for (int j = 0 ; j < BOUNDARYSIZE; ++j) {\n			GameRecord[game_length][i][j] = Board[i][j];\n		    }\n		}\n}\n/* \n * This function randomly generate one legal move (x, y) with return value x*10+y,\n * if there is no legal move the function will return 0.\n * */\nint genmove(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int turn, int time_limit, int game_length, int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE]) {\n    clock_t start_t, end_t, now_t;\n    // record start time\n    start_t = clock();\n    // calculate the time bound\n    end_t = start_t + CLOCKS_PER_SEC * time_limit;\n\n    int MoveList[HISTORYLENGTH];\n    int num_legal_moves = 0;\n    int return_move = 0;\n\n    num_legal_moves = gen_legal_move(Board, turn, game_length, GameRecord, MoveList);\n\n    return_move = rand_pick_move(num_legal_moves, MoveList);\n\n    do_move(Board, turn, return_move);\n\n    return return_move % 100;\n}\n/*\n * This function counts the number of points remains in the board by Black's view\n * */\ndouble final_score(int Board[BOUNDARYSIZE][BOUNDARYSIZE]) {\n    int black, white;\n    black = white = 0;\n    int is_black, is_white;\n    for (int i = 1 ; i <= BOARDSIZE; ++i) {\n	for (int j = 1; j <= BOARDSIZE; ++j) {\n	    switch(Board[i][j]) {\n		case EMPTY:\n		    is_black = is_white = 0;\n		    for(int d = 0 ; d < MAXDIRECTION; ++d) {\n			if (Board[i+DirectionX[d]][j+DirectionY[d]] == BLACK) is_black = 1;\n			if (Board[i+DirectionX[d]][j+DirectionY[d]] == WHITE) is_white = 1;\n		    }\n		    if (is_black + is_white == 1) {\n			black += is_black;\n			white += is_white;\n		    }\n		    break;\n		case WHITE:\n		    white++;\n		    break;\n		case BLACK:\n		    black++;\n		    break;\n	    }\n	}\n    }\n    return black - white;\n}\n/* \n * Following are commands for Go Text Protocol (GTP)\n *\n * */\nconst char *KnownCommands[]={\n    \"protocol_version\",\n    \"name\",\n    \"version\",\n    \"known_command\",\n    \"list_commands\",\n    \"quit\",\n    \"boardsize\",\n    \"clear_board\",\n    \"komi\",\n    \"play\",\n    \"genmove\",\n    \"undo\",\n    \"quit\",\n    \"showboard\",\n    \"final_score\"\n};\n\nvoid gtp_final_score(int Board[BOUNDARYSIZE][BOUNDARYSIZE]) {\n    double result;\n    result = final_score(Board);\n    result -= _komi;\n    cout << \"= \";\n    if (result > 0.0) { // Black win\n	cout << \"B+\" << result << endl << endl<< endl;;\n    }\n    if (result < 0.0) { // White win\n	cout << \"W+\" << -result << endl << endl<< endl;;\n    }\n    else { // draw\n	cout << \"0\" << endl << endl<< endl;;\n    }\n}\nvoid gtp_undo(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int game_length, int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE]) {\n    if (game_length!=0) {\n	for (int i = 1; i <= BOARDSIZE; ++i) {\n	    for (int j = 1; j <= BOARDSIZE; ++j) {\n		Board[i][j] = GameRecord[game_length][i][j];\n	    }\n	}\n    }\n    cout << \"= \" << endl << endl;\n}\nvoid gtp_showboard(int Board[BOUNDARYSIZE][BOUNDARYSIZE]) {\n    for (int i = 1; i <=BOARDSIZE; ++i) {\n	cout << \"#\";\n	cout <<10-i;\n	for (int j = 1; j <=BOARDSIZE; ++j) {\n	    switch(Board[i][j]) {\n		case EMPTY: cout << \" .\";break;\n		case BLACK: cout << \" X\";break;\n		case WHITE: cout << \" O\";break;\n	    }\n	}\n	cout << endl;\n    }\n    cout << \"#  \";\n    for (int i = 1; i <=BOARDSIZE; ++i) \n	cout << LabelX[i] <<\" \";\n    cout << endl;\n    cout << endl;\n\n}\nvoid gtp_protocol_version() {\n    cout <<\"= 2\"<<endl<< endl;\n}\nvoid gtp_name() {\n    cout <<\"= TCG-randomGo99\" << endl<< endl;\n}\nvoid gtp_version() {\n    cout << \"= 1.02\" << endl << endl;\n}\nvoid gtp_list_commands(){\n    cout <<\"= \";\n    for (int i = 0 ; i < NUMGTPCOMMANDS; ++i) {\n	cout <<KnownCommands[i] << endl;\n    }\n    cout << endl;\n}\nvoid gtp_known_command(const char Input[]) {\n    for (int i = 0 ; i < NUMGTPCOMMANDS; ++i) {\n	if (strcmp(Input, KnownCommands[i])==0) {\n	    cout << \"= true\" << endl<< endl;\n	    return;\n	}\n    }\n    cout << \"= false\" << endl<< endl;\n}\nvoid gtp_boardsize(int size) {\n    if (size!=9) {\n	cout << \"? unacceptable size\" << endl<< endl;\n    }\n    else {\n	_board_size = size;\n	cout << \"= \"<<endl<<endl;\n    }\n}\nvoid gtp_clear_board(int Board[BOUNDARYSIZE][BOUNDARYSIZE], int NumCapture[]) {\n    reset(Board);\n    NumCapture[BLACK] = NumCapture[WHITE] = 0;\n    cout << \"= \"<<endl<<endl;\n}\nvoid gtp_komi(double komi) {\n    _komi = komi;\n    cout << \"= \"<<endl<<endl;\n}\nvoid gtp_play(char Color[], char Move[], int Board[BOUNDARYSIZE][BOUNDARYSIZE], int game_length, int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE]) {\n    int turn, move_i, move_j;\n    if (Color[0] =='b' || Color[0] == 'B')\n	turn = BLACK;\n    else\n	turn = WHITE;\n    if (strcmp(Move, \"PASS\") == 0 || strcmp(Move, \"pass\")==0) {\n	record(Board, GameRecord, game_length+1);\n    }\n    else {\n	// [ABCDEFGHJ][1-9], there is no I in the index.\n	Move[0] = toupper(Move[0]);\n	move_j = Move[0]-'A'+1;\n	if (move_j == 10) move_j = 9;\n	move_i = 10-(Move[1]-'0');\n	update_board(Board, move_i, move_j, turn);\n	record(Board, GameRecord, game_length+1);\n    }\n    cout << \"= \"<<endl<<endl;\n}\nvoid gtp_genmove(int Board[BOUNDARYSIZE][BOUNDARYSIZE], char Color[], int time_limit, int game_length, int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE]){\n    int turn = (Color[0]=='b'||Color[0]=='B')?BLACK:WHITE;\n    int move = genmove(Board, turn, time_limit, game_length, GameRecord);\n    int move_i, move_j;\n    record(Board, GameRecord, game_length+1);\n    if (move==0) {\n	cout << \"= PASS\" << endl<< endl<< endl;\n    }\n    else {\n	move_i = (move%100)/10;\n	move_j = (move%10);\n//	cerr << \"#turn(\"<<game_length<<\"): (move, move_i,move_j)\" << turn << \": \" << move<< \" \" << move_i << \" \" << move_j << endl;\n	cout << \"= \" << LabelX[move_j]<<10-move_i<<endl<< endl;\n    }\n}\n/*\n * This main function is used of the gtp protocol\n * */\nvoid gtp_main(int display) {\n    char Input[COMMANDLENGTH]=\"\";\n    char Command[COMMANDLENGTH]=\"\";\n    char Parameter[COMMANDLENGTH]=\"\";\n    char Move[4]=\"\";\n    char Color[6]=\"\";\n    int ivalue;\n    double dvalue;\n    int Board[BOUNDARYSIZE][BOUNDARYSIZE]={{0}};\n    int NumCapture[3]={0};// 1:Black, 2: White\n    int time_limit = DEFAULTTIME;\n    int GameRecord[MAXGAMELENGTH][BOUNDARYSIZE][BOUNDARYSIZE]={{{0}}};\n    int game_length = 0;\n    if (display==1) {\n	gtp_list_commands();\n	gtp_showboard(Board);\n    }\n    while (gets(Input) != 0) {\n	sscanf(Input, \"%s\", Command);\n	if (Command[0]== '#')\n	    continue;\n\n	if (strcmp(Command, \"protocol_version\")==0) {\n	    gtp_protocol_version();\n	}\n	else if (strcmp(Command, \"name\")==0) {\n	    gtp_name();\n	}\n	else if (strcmp(Command, \"version\")==0) {\n	    gtp_version();\n	}\n	else if (strcmp(Command, \"list_commands\")==0) {\n	    gtp_list_commands();\n	}\n	else if (strcmp(Command, \"known_command\")==0) {\n	    sscanf(Input, \"known_command %s\", Parameter);\n	    gtp_known_command(Parameter);\n	}\n	else if (strcmp(Command, \"boardsize\")==0) {\n	    sscanf(Input, \"boardsize %d\", &ivalue);\n	    gtp_boardsize(ivalue);\n	}\n	else if (strcmp(Command, \"clear_board\")==0) {\n	    gtp_clear_board(Board, NumCapture);\n	    game_length = 0;\n	}\n	else if (strcmp(Command, \"komi\")==0) {\n	    sscanf(Input, \"komi %lf\", &dvalue);\n	    gtp_komi(dvalue);\n	}\n	else if (strcmp(Command, \"play\")==0) {\n	    sscanf(Input, \"play %s %s\", Color, Move);\n	    gtp_play(Color, Move, Board, game_length, GameRecord);\n	    game_length++;\n	    if (display==1) {\n		gtp_showboard(Board);\n	    }\n	}\n	else if (strcmp(Command, \"genmove\")==0) {\n	    sscanf(Input, \"genmove %s\", Color);\n	    gtp_genmove(Board, Color, time_limit, game_length, GameRecord);\n	    game_length++;\n	    if (display==1) {\n		gtp_showboard(Board);\n	    }\n	}\n	else if (strcmp(Command, \"quit\")==0) {\n	    break;\n	}\n	else if (strcmp(Command, \"showboard\")==0) {\n	    gtp_showboard(Board);\n	}\n	else if (strcmp(Command, \"undo\")==0) {\n	    game_length--;\n	    gtp_undo(Board, game_length, GameRecord);\n	    if (display==1) {\n		gtp_showboard(Board);\n	    }\n	}\n	else if (strcmp(Command, \"final_score\")==0) {\n	    if (display==1) {\n		gtp_showboard(Board);\n	    }\n	    gtp_final_score(Board);\n	}\n    }\n}\nint main(int argc, char* argv[]) {\n//    int type = GTPVERSION;// 1: local version, 2: gtp version\n    int type = GTPVERSION;// 1: local version, 2: gtp version\n    int display = 0; // 1: display, 2 nodisplay\n    if (argc > 1) {\n	if (strcmp(argv[1], \"-display\")==0) {\n	    display = 1;\n	}\n	if (strcmp(argv[1], \"-nodisplay\")==0) {\n	    display = 0;\n	}\n    }\n    gtp_main(display);\n    return 0;\n}\ngtp_name",
			"random",
			"rand_pick_move",
			"gen_legal_move",
			"check_",
			"gen_legal_move",
			"Liberties",
			"rand_pick_move",
			"update_board",
			"random",
			"rand",
			"update_board",
			"do_move",
			"rand_pick_move",
			"genmove",
			"ConnectBoard",
			"count_liberty",
			"TCG-rand",
			"DEFAULTTIME",
			"time_limit",
			"tmpx",
			"int tmpx",
			"count_liberty",
			"readResponse(timeout)",
			"waitForMessage",
			"isProgramDead",
			"m_black",
			"isProgramDead",
			"m_gtp.is",
			"computer-both",
			"m_gtp",
			"isProgramDead",
			"MSG_PROGRAM_TERMINATED_4",
			"// GoGui.java\n\npackage net.sf.gogui.gogui;\n\nimport java.awt.BorderLayout;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.Frame;\nimport java.awt.Insets;\nimport java.awt.Toolkit;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.MouseWheelEvent;\nimport java.awt.event.MouseWheelListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport static java.text.MessageFormat.format;\nimport java.util.ArrayList;\nimport java.util.prefs.BackingStoreException;\nimport java.util.prefs.Preferences;\nimport java.util.regex.Pattern;\nimport javax.swing.JDialog;\nimport javax.swing.JFrame;\nimport javax.swing.JLayeredPane;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JSplitPane;\nimport javax.swing.SwingUtilities;\nimport javax.swing.WindowConstants;\nimport net.sf.gogui.game.ConstClock;\nimport net.sf.gogui.game.ConstGame;\nimport net.sf.gogui.game.ConstGameInfo;\nimport net.sf.gogui.game.ConstGameTree;\nimport net.sf.gogui.game.ConstNode;\nimport net.sf.gogui.game.Game;\nimport net.sf.gogui.game.GameTree;\nimport net.sf.gogui.game.GameInfo;\nimport net.sf.gogui.game.MarkType;\nimport net.sf.gogui.game.NodeUtil;\nimport net.sf.gogui.game.StringInfo;\nimport net.sf.gogui.game.StringInfoColor;\nimport net.sf.gogui.game.TimeSettings;\nimport net.sf.gogui.gamefile.GameFile;\nimport net.sf.gogui.gamefile.GameReader;\nimport net.sf.gogui.gamefile.GameWriter;\nimport net.sf.gogui.go.Board;\nimport net.sf.gogui.go.BoardUtil;\nimport net.sf.gogui.go.ConstBoard;\nimport net.sf.gogui.go.ConstPointList;\nimport net.sf.gogui.go.CountScore;\nimport net.sf.gogui.go.GoColor;\nimport static net.sf.gogui.go.GoColor.BLACK;\nimport static net.sf.gogui.go.GoColor.WHITE;\nimport static net.sf.gogui.go.GoColor.EMPTY;\nimport net.sf.gogui.go.GoPoint;\nimport net.sf.gogui.go.InvalidKomiException;\nimport net.sf.gogui.go.Komi;\nimport net.sf.gogui.go.Move;\nimport net.sf.gogui.go.PointList;\nimport net.sf.gogui.go.Score;\nimport net.sf.gogui.go.Score.ScoringMethod;\nimport static net.sf.gogui.gogui.I18n.i18n;\nimport net.sf.gogui.gtp.AnalyzeCommand;\nimport net.sf.gogui.gtp.AnalyzeDefinition;\nimport net.sf.gogui.gtp.AnalyzeType;\nimport net.sf.gogui.gtp.AnalyzeUtil;\nimport net.sf.gogui.gtp.GtpClient;\nimport net.sf.gogui.gtp.GtpClientUtil;\nimport net.sf.gogui.gtp.GtpCommand;\nimport net.sf.gogui.gtp.GtpError;\nimport net.sf.gogui.gtp.GtpResponseFormatError;\nimport net.sf.gogui.gtp.GtpSynchronizer;\nimport net.sf.gogui.gtp.GtpUtil;\nimport net.sf.gogui.gui.AnalyzeDialog;\nimport net.sf.gogui.gui.AnalyzeShow;\nimport net.sf.gogui.gui.BoardSizeDialog;\nimport net.sf.gogui.gui.Bookmark;\nimport net.sf.gogui.gui.BookmarkEditor;\nimport net.sf.gogui.gui.Comment;\nimport net.sf.gogui.gui.ConstGuiBoard;\nimport net.sf.gogui.gui.ContextMenu;\nimport net.sf.gogui.gui.FindDialog;\nimport net.sf.gogui.gui.GameInfoDialog;\nimport net.sf.gogui.gui.GameInfoPanel;\nimport net.sf.gogui.gui.GameTreePanel;\nimport net.sf.gogui.gui.GameTreeViewer;\nimport net.sf.gogui.gui.GtpShell;\nimport net.sf.gogui.gui.GuiAction;\nimport net.sf.gogui.gui.GuiBoard;\nimport net.sf.gogui.gui.GuiBoardUtil;\nimport net.sf.gogui.gui.GuiGtpClient;\nimport net.sf.gogui.gui.GuiUtil;\nimport net.sf.gogui.gui.FileDialogs;\nimport net.sf.gogui.gui.Help;\nimport net.sf.gogui.gui.LiveGfx;\nimport net.sf.gogui.gui.MessageDialogs;\nimport net.sf.gogui.gui.ObjectListEditor;\nimport net.sf.gogui.gui.ParameterDialog;\nimport net.sf.gogui.gui.Program;\nimport net.sf.gogui.gui.ProgramEditor;\nimport net.sf.gogui.gui.RecentFileMenu;\nimport net.sf.gogui.gui.Session;\nimport net.sf.gogui.gui.ScoreDialog;\nimport net.sf.gogui.gui.StatusBar;\nimport net.sf.gogui.gui.TimeLeftDialog;\nimport net.sf.gogui.sgf.SgfError;\nimport net.sf.gogui.sgf.SgfReader;\nimport net.sf.gogui.sgf.SgfWriter;\nimport net.sf.gogui.tex.TexWriter;\nimport net.sf.gogui.text.TextParser;\nimport net.sf.gogui.text.ParseError;\nimport net.sf.gogui.thumbnail.ThumbnailCreator;\nimport net.sf.gogui.thumbnail.ThumbnailPlatform;\nimport net.sf.gogui.util.ErrorMessage;\nimport net.sf.gogui.util.FileUtil;\nimport net.sf.gogui.util.ObjectUtil;\nimport net.sf.gogui.util.LineReader;\nimport net.sf.gogui.util.Platform;\nimport net.sf.gogui.util.ProgressShow;\nimport net.sf.gogui.util.StringUtil;\nimport net.sf.gogui.version.Version;\n\n/** Graphical user interface to a Go program. */\npublic class GoGui\n    extends JFrame\n    implements AnalyzeDialog.Listener, GuiBoard.Listener,\n               GameTreeViewer.Listener, GtpShell.Listener,\n               ScoreDialog.Listener, GoGuiMenuBar.Listener,\n               ContextMenu.Listener, LiveGfx.Listener\n{\n    public enum ShowVariations\n    {\n        CHILDREN,\n\n        SIBLINGS,\n\n        NONE\n    }\n\n    public GoGui(String program, File file, int move, String time,\n                 boolean verbose, boolean initComputerColor,\n                 boolean computerBlack, boolean computerWhite, boolean auto,\n                 boolean register, String gtpFile, String gtpCommand,\n                 File analyzeCommandsFile)\n        throws GtpError, ErrorMessage\n    {\n        int boardSize = m_prefs.getInt(\"boardsize\", GoPoint.DEFAULT_SIZE);\n        m_beepAfterMove = m_prefs.getBoolean(\"beep-after-move\", true);\n        m_initialFile = file;\n        m_gtpFile = gtpFile;\n        m_gtpCommand = gtpCommand;\n        m_analyzeCommandsFile = analyzeCommandsFile;\n        m_move = move;\n        m_register = register;\n        if (initComputerColor)\n        {\n            m_computerBlack = computerBlack;\n            m_computerWhite = computerWhite;\n        }\n        else if (m_prefs.getBoolean(\"computer-none\", false))\n        {\n            m_computerBlack = false;\n            m_computerWhite = false;\n        }\n        else\n        {\n            m_computerBlack = false;\n            m_computerWhite = true;\n        }\n        m_auto = auto;\n        m_verbose = verbose;\n        m_showInfoPanel = true;\n        m_showToolbar = false;\n\n        Container contentPane = getContentPane();\n        m_innerPanel = new JPanel(new BorderLayout());\n        contentPane.add(m_innerPanel, BorderLayout.CENTER);\n        m_toolBar = new GoGuiToolBar(this);\n\n        m_infoPanel = new JPanel(new BorderLayout());\n        m_game = new Game(boardSize);\n        m_gameInfoPanel = new GameInfoPanel(m_game);\n        m_gameInfoPanel.setBorder(GuiUtil.createSmallEmptyBorder());\n        m_infoPanel.add(m_gameInfoPanel, BorderLayout.NORTH);\n        m_guiBoard = new GuiBoard(boardSize);\n        m_showAnalyzeText = new ShowAnalyzeText(this, m_guiBoard);\n\n        m_statusBar = new StatusBar();\n        m_innerPanel.add(m_statusBar, BorderLayout.SOUTH);\n        Comment.Listener commentListener = new Comment.Listener()\n            {\n                public void changed(String comment)\n                {\n                    m_game.setComment(comment);\n                    // Cannot call updateViews, which calls\n                    // Comment.setComment(), in comment callback\n                    SwingUtilities.invokeLater(new Runnable() {\n                            public void run() {\n                                updateViews(false);\n                            } });\n                }\n\n                public void textSelected(String text)\n                {\n                    GoGui.this.textSelected(text);\n                }\n            };\n        m_comment = new Comment(commentListener);\n        boolean monoFont = m_prefs.getBoolean(\"comment-font-fixed\", false);\n        m_comment.setMonoFont(monoFont);\n        m_infoPanel.add(m_comment, BorderLayout.CENTER);\n        m_splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n                                     m_guiBoard, m_infoPanel);\n        m_splitPane.setResizeWeight(1);\n        m_innerPanel.add(m_splitPane, BorderLayout.CENTER);\n        addWindowListener(new WindowAdapter() {\n                public void windowActivated(WindowEvent e) {\n                    m_guiBoard.requestFocusInWindow();\n                }\n\n                public void windowClosing(WindowEvent event) {\n                    close();\n                }\n            });\n        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);\n        GuiUtil.setGoIcon(this);\n        RecentFileMenu.Listener recentListener = new RecentFileMenu.Listener()\n            {\n                public void fileSelected(String label, File file) {\n                    actionOpenFile(file);\n                }\n            };\n        RecentFileMenu.Listener recentGtp = new RecentFileMenu.Listener() {\n                public void fileSelected(String label, File file) {\n                    actionSendFile(file);\n                }\n            };\n        m_menuBar = new GoGuiMenuBar(m_actions, recentListener, recentGtp,\n                                     this);\n        // enums are stored as int's for compatibility with earlier versions\n        // of GoGui\n        try\n        {\n            m_treeLabels =\n                GameTreePanel.Label.values()[\n                         m_prefs.getInt(\"gametree-labels\",\n                                        GameTreePanel.Label.NUMBER.ordinal())];\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            m_treeLabels = GameTreePanel.Label.NUMBER;\n        }\n        try\n        {\n            m_treeSize =\n                GameTreePanel.Size.values()[\n                         m_prefs.getInt(\"gametree-size\",\n                                        GameTreePanel.Size.NORMAL.ordinal())];\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            m_treeSize = GameTreePanel.Size.NORMAL;\n        }\n\n        try\n        {\n            m_showVariations =\n                ShowVariations.values()[\n                           m_prefs.getInt(\"show-variations\",\n                                          ShowVariations.CHILDREN.ordinal())];\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            m_showVariations = ShowVariations.CHILDREN;\n        }\n\n        m_showSubtreeSizes =\n            m_prefs.getBoolean(\"gametree-show-subtree-sizes\", false);\n        m_autoNumber = m_prefs.getBoolean(\"gtpshell-autonumber\", false);\n        m_commandCompletion =\n            ! m_prefs.getBoolean(\"gtpshell-disable-completions\", false);\n        m_timeStamp = m_prefs.getBoolean(\"gtpshell-timestamp\", false);\n        m_showLastMove = m_prefs.getBoolean(\"show-last-move\", true);\n        m_showMoveNumbers = m_prefs.getBoolean(\"show-move-numbers\", false);\n        boolean showCursor = m_prefs.getBoolean(\"show-cursor\", false);\n        boolean showGrid = m_prefs.getBoolean(\"show-grid\", false);\n        m_guiBoard.setShowCursor(showCursor);\n        m_guiBoard.setShowGrid(showGrid);\n        setJMenuBar(m_menuBar);\n        setMinimumSize();\n        m_programCommand = program;\n        if (m_programCommand != null && m_programCommand.trim().equals(\"\"))\n            m_programCommand = null;\n        if (time != null)\n            m_timeSettings = TimeSettings.parse(time);\n        protectGui(); // Show wait cursor\n        SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    initialize();\n                } });\n    }\n\n    public void actionAbout()\n    {\n        String command = null;\n        if (m_gtp != null)\n            command = m_gtp.getProgramCommand();\n        AboutDialog.show(this, getProgramLabel(), m_version, command,\n                         m_messageDialogs);\n    }\n\n    public void actionAddBookmark()\n    {\n        if (m_gameFile == null)\n        {\n            showError(i18n(\"MSG_CANNOT_SET_BOOKMARK_NO_FILE\"),\n                      i18n(\"MSG_CANNOT_SET_BOOKMARK_NO_FILE_2\"),\n                      false);\n            return;\n        }\n        if (isModified())\n        {\n            showError(i18n(\"MSG_CANNOT_SET_BOOKMARK_MODIFIED\"),\n                      i18n(\"MSG_CANNOT_SET_BOOKMARK_MODIFIED_2\"),\n                      false);\n            return;\n        }\n        if (getCurrentNode().getFatherConst() != null\n            && getCurrentNode().getMove() == null)\n        {\n            showError(i18n(\"MSG_CANNOT_SET_BOOKMARK_NODE\"),\n                      i18n(\"MSG_CANNOT_SET_BOOKMARK_NODE_2\"),\n                      false);\n            return;\n        }\n        String variation = NodeUtil.getVariationString(getCurrentNode());\n        int move = NodeUtil.getMoveNumber(getCurrentNode());\n        Bookmark bookmark = new Bookmark(m_gameFile.m_file, move, variation);\n        BookmarkEditor editor = new BookmarkEditor();\n        bookmark = editor.editItem(this, i18n(\"TIT_ADD_BOOKMARK\"), bookmark,\n                                   true, m_messageDialogs);\n        if (bookmark == null)\n            return;\n        m_bookmarks.add(bookmark);\n        m_menuBar.setBookmarks(m_bookmarks);\n        Bookmark.save(m_bookmarks);\n    }\n\n    public void actionAttachProgram(int index)\n    {\n        m_prefs.putInt(\"program\", index);\n        actionAttachProgram(m_programs.get(index));\n    }\n\n    public void actionAttachProgram(final Program program)\n    {\n        if (! checkCommandInProgress())\n            return;\n        protectGui();\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    try\n                    {\n                        attachNewProgram(program.m_command, program);\n                    }\n                    finally\n                    {\n                        unprotectGui();\n                    }\n                }\n            };\n        SwingUtilities.invokeLater(runnable);\n    }\n\n    public void actionBackToMainVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node = NodeUtil.getBackToMainVariation(getCurrentNode());\n        actionGotoNode(node);\n    }\n\n    public void actionBackward(int n)\n    {\n        if (! checkStateChangePossible())\n            return;\n        boolean protectGui = (m_gtp != null\n                              && (n > 1 || ! m_gtp.isSupported(\"undo\")));\n        actionGotoNode(NodeUtil.backward(getCurrentNode(), n), protectGui);\n    }\n\n    public void actionBeginning()\n    {\n        if (! checkStateChangePossible())\n            return;\n        actionBackward(NodeUtil.getDepth(getCurrentNode()));\n    }\n\n    public void actionBoardSize(int size)\n    {\n        if (! checkCommandInProgress())\n            return;\n        actionNewGame(size);\n        m_prefs.putInt(\"boardsize\", size);\n    }\n\n    public void actionBoardSizeOther()\n    {\n        if (! checkCommandInProgress())\n            return;\n        int size = BoardSizeDialog.show(this, getBoardSize(),\n                                        m_messageDialogs);\n        if (size < 1 || size > GoPoint.MAX_SIZE)\n            return;\n        actionBoardSize(size);\n    }\n\n    public void actionClearAnalyzeCommand()\n    {\n        if (! checkCommandInProgress())\n            return;\n        clearAnalyzeCommand();\n    }\n\n    public void actionClockHalt()\n    {\n        if (! getClock().isRunning())\n            return;\n        m_game.haltClock();\n        updateViews(false);\n    }\n\n    public void actionClockResume()\n    {\n        if (getClock().isRunning())\n            return;\n        m_game.resumeClock();\n        updateViews(false);\n    }\n\n    public void actionClockStart()\n    {\n        if (getClock().isRunning())\n            return;\n        m_game.startClock();\n        updateViews(false);\n    }\n\n    public void actionComputerColor(boolean isBlack, boolean isWhite)\n    {\n        boolean computerNone = (! isBlack && ! isWhite);\n        m_prefs.putBoolean(\"computer-none\", computerNone);\n        m_computerBlack = isBlack;\n        m_computerWhite = isWhite;\n        if (! isCommandInProgress())\n            checkComputerMove();\n        updateViews(false);\n    }\n\n    public void actionDeleteSideVariations()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! NodeUtil.isInMainVariation(getCurrentNode()))\n            return;\n        String disableKey = \"net.sf.gogui.gogui.GoGui.delete-side-variations\";\n        if (! m_messageDialogs.showQuestion(disableKey, this,\n                                            i18n(\"MSG_DELETE_VARIATIONS\"),\n                                            i18n(\"MSG_DELETE_VARIATIONS_2\"),\n                                            i18n(\"LB_DELETE\"),\n                                            false))\n            return;\n        m_game.keepOnlyMainVariation();\n        boardChangedBegin(false, true);\n    }\n\n    public void actionDetachProgram()\n    {\n        if (m_gtp == null)\n            return;\n        if (isCommandInProgress()\n            && ! showQuestion(format(i18n(\"MSG_TERMINATE_COMMAND_IN_PROGRESS\"),\n                                     getProgramLabel()),\n                              i18n(\"MSG_TERMINATE_COMMAND_IN_PROGRESS_2\"),\n                              i18n(\"LB_TERMINATE\"), true))\n            return;\n        m_prefs.putInt(\"program\", -1);\n        protectGui();\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    try\n                    {\n                        saveSession();\n                        detachProgram();\n                        updateViews(false);\n                    }\n                    finally\n                    {\n                        unprotectGui();\n                    }\n                }\n            };\n        SwingUtilities.invokeLater(runnable);\n    }\n\n    public void actionDisposeAnalyzeDialog()\n    {\n        if (m_analyzeDialog != null)\n        {\n            clearAnalyzeCommand();\n            saveSession();\n            m_analyzeDialog.dispose();\n            m_analyzeDialog = null;\n        }\n    }\n\n    public void actionDisposeTree()\n    {\n        if (m_gameTreeViewer != null)\n        {\n            saveSession();\n            m_gameTreeViewer.dispose();\n            m_gameTreeViewer = null;\n            updateViews(false);\n        }\n    }\n\n    public void actionHelp()\n    {\n        ClassLoader classLoader = getClass().getClassLoader();\n        URL url = classLoader.getResource(\"net/sf/gogui/doc/index.html\");\n        if (url == null)\n        {\n            showError(i18n(\"MSG_HELP_NOT_FOUND\"), \"\");\n            return;\n        }\n        if (m_help == null)\n        {\n            m_help = new Help(url, m_messageDialogs,\n                              i18n(\"TIT_HELP\") + \" - \" + i18n(\"LB_GOGUI\"));\n            m_session.restoreSize(m_help.getWindow(), \"help\");\n        }\n        m_help.getWindow().setVisible(true);\n        m_help.getWindow().toFront();\n    }\n\n    public void actionEditBookmarks()\n    {\n        BookmarkEditor editor = new BookmarkEditor();\n        ObjectListEditor<Bookmark> listEditor =\n            new ObjectListEditor<Bookmark>();\n        if (! listEditor.edit(this, i18n(\"TIT_EDIT_BOOKMARKS\"), m_bookmarks,\n                              editor, m_messageDialogs))\n            return;\n        m_menuBar.setBookmarks(m_bookmarks);\n        Bookmark.save(m_bookmarks);\n    }\n\n    public void actionEditLabel(GoPoint point)\n    {\n        String value = getCurrentNode().getLabel(point);\n        Object message = format(i18n(\"MSG_EDIT_LABEL\"), point);\n        value = (String)JOptionPane.showInputDialog(this, message,\n                                                    i18n(\"TIT_EDIT_LABEL\"),\n                                                    JOptionPane.PLAIN_MESSAGE,\n                                                    null, null, value);\n        if (value == null)\n            return;\n        m_game.setLabel(point, value);\n        m_guiBoard.setLabel(point, value);\n        updateViews(false);\n    }\n\n    public void actionEditPrograms()\n    {\n        ProgramEditor editor = new ProgramEditor();\n        ObjectListEditor<Program> listEditor = new ObjectListEditor<Program>();\n        if (! listEditor.edit(this, i18n(\"TIT_EDIT_PROGRAMS\"), m_programs,\n                              editor, m_messageDialogs))\n            return;\n        m_menuBar.setPrograms(m_programs);\n        m_prefs.putInt(\"program\", -1);\n        Program.save(m_programs);\n    }\n\n    public void actionEnd()\n    {\n        actionForward(NodeUtil.getNodesLeft(getCurrentNode()));\n    }\n\n    public void actionExportLatexMainVariation()\n    {\n        File file = showSave(i18n(\"TIT_EXPORT_LATEX\"));\n        if (file == null)\n            return;\n        try\n        {\n            OutputStream out = new FileOutputStream(file);\n            String title =\n                FileUtil.removeExtension(new File(file.getName()), \"tex\");\n            new TexWriter(title, out, getTree());\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_EXPORT_FAILED\"), e);\n        }\n    }\n\n    public void actionExportLatexPosition()\n    {\n        File file = showSave(i18n(\"TIT_EXPORT_LATEX_POSITION\"));\n        if (file == null)\n            return;\n        try\n        {\n            OutputStream out = new FileOutputStream(file);\n            String title = FileUtil.removeExtension(new File(file.getName()),\n                                                     \"tex\");\n            new TexWriter(title, out, getBoard(),\n                          GuiBoardUtil.getLabels(m_guiBoard),\n                          GuiBoardUtil.getMark(m_guiBoard),\n                          GuiBoardUtil.getMarkTriangle(m_guiBoard),\n                          GuiBoardUtil.getMarkCircle(m_guiBoard),\n                          GuiBoardUtil.getMarkSquare(m_guiBoard),\n                          GuiBoardUtil.getSelects(m_guiBoard));\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_EXPORT_FAILED\"), e);\n        }\n    }\n\n    public void actionExportSgfPosition()\n    {\n        File file = FileDialogs.showSaveSgf(this, m_messageDialogs);\n        if (file == null)\n            return;\n        try\n        {\n            savePosition(file);\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_EXPORT_FAILED\"), e);\n        }\n    }\n\n    public void actionExportTextPosition()\n    {\n        File file = showSave(i18n(\"MSG_EXPORT_TEXT\"));\n        if (file == null)\n            return;\n        try\n        {\n            String text = BoardUtil.toString(getBoard(), false, false);\n            PrintStream out = new PrintStream(file);\n            out.print(text);\n            out.close();\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_EXPORT_FAILED\"), e);\n        }\n    }\n\n    public void actionExportPng()\n    {\n        ExportPng.run(this, m_guiBoard, m_prefs, m_messageDialogs);\n    }\n\n    public void actionExportTextPositionToClipboard()\n    {\n        GuiUtil.copyToClipboard(BoardUtil.toString(getBoard(), false, false));\n    }\n\n    public void actionFind()\n    {\n        if (! checkStateChangePossible())\n            return;\n        Pattern pattern = FindDialog.run(this, m_comment.getSelectedText(),\n                                         m_messageDialogs);\n        if (pattern == null)\n            return;\n        m_pattern = pattern;\n        if (NodeUtil.commentContains(getCurrentNode(), m_pattern))\n            m_comment.markAll(m_pattern);\n        else\n            actionFindNext();\n    }\n\n    public void actionFindNext()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (m_pattern == null)\n            return;\n        protectGui();\n        showStatus(i18n(\"STAT_FIND_SEARCHING_COMMENTS\"));\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    try\n                    {\n                        ConstNode root = getTree().getRootConst();\n                        ConstNode currentNode = getCurrentNode();\n                        ConstNode node =\n                            NodeUtil.findInComments(currentNode, m_pattern);\n                        boolean cancel = false;\n                        if (node == null && getCurrentNode() != root)\n                        {\n                            unprotectGui();\n                            if (showQuestion(i18n(\"MSG_FIND_CONTINUE\"),\n                                             i18n(\"MSG_FIND_CONTINUE_2\"),\n                                             i18n(\"LB_FIND_CONTINUE\"), false))\n                            {\n                                protectGui();\n                                node = root;\n                                if (! NodeUtil.commentContains(node,\n                                                               m_pattern))\n                                    node =\n                                        NodeUtil.findInComments(node,\n                                                                m_pattern);\n                            }\n                            else\n                                cancel = true;\n                        }\n                        if (! cancel)\n                        {\n                            if (node == null)\n                            {\n                                unprotectGui();\n                                showInfo(i18n(\"MSG_FIND_NOT_FOUND\"),\n                                         format(i18n(\"MSG_FIND_NOT_FOUND_2\"),\n                                                m_pattern),\n                                         false);\n                                m_pattern = null;\n                            }\n                            else\n                            {\n                                gotoNode(node);\n                                boardChangedBegin(false, false);\n                                m_comment.markAll(m_pattern);\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        unprotectGui();\n                        clearStatus();\n                    }\n                }\n            };\n        SwingUtilities.invokeLater(runnable);\n    }\n\n    public void actionFindNextComment()\n    {\n        if (! checkStateChangePossible())\n            return;\n        protectGui();\n        showStatus(i18n(\"STAT_FIND_SEARCHING_COMMENTS\"));\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    try\n                    {\n                        ConstNode root = getTree().getRootConst();\n                        ConstNode currentNode = getCurrentNode();\n                        ConstNode node = NodeUtil.findNextComment(currentNode);\n                        boolean cancel = false;\n                        if (node == null && getCurrentNode() != root)\n                        {\n                            unprotectGui();\n                            if (showQuestion(i18n(\"MSG_FIND_CONTINUE\"),\n                                             i18n(\"MSG_FIND_CONTINUE_2\"),\n                                             i18n(\"LB_FIND_CONTINUE\"), false))\n                            {\n                                protectGui();\n                                node = root;\n                                if (! node.hasComment())\n                                    node = NodeUtil.findNextComment(node);\n                            }\n                            else\n                                cancel = true;\n                        }\n                        if (! cancel)\n                        {\n                            if (node == null)\n                            {\n                                unprotectGui();\n                                showInfo(i18n(\"MSG_FIND_NO_COMMENT_FOUND\"),\n                                         null, false);\n                            }\n                            else\n                            {\n                                gotoNode(node);\n                                boardChangedBegin(false, false);\n                            }\n                        }\n                    }\n                    finally\n                    {\n                        unprotectGui();\n                        clearStatus();\n                    }\n                }\n            };\n        SwingUtilities.invokeLater(runnable);\n    }\n\n    public void actionForward(int n)\n    {\n        if (! checkStateChangePossible())\n            return;\n        boolean protectGui = (m_gtp != null && n > 1);\n        actionGotoNode(NodeUtil.forward(getCurrentNode(), n), protectGui);\n    }\n\n    public void actionGameInfo()\n    {\n        if (! checkCommandInProgress())\n            // Changes in game info may send GTP commands\n            return;\n        ConstNode node = m_game.getGameInfoNode();\n        GameInfo info = new GameInfo(node.getGameInfoConst());\n        GameInfoDialog.show(this, info, m_messageDialogs);\n        m_game.setGameInfo(info, node);\n        currentNodeChanged(); // updates komi, time settings\n        Komi prefsKomi = getPrefsKomi();\n        Komi komi = info.getKomi();\n        if (komi != null && ! komi.equals(prefsKomi) && info.getHandicap() == 0)\n            m_prefs.put(\"komi\", komi.toString());\n        if (info.getTimeSettings() != null\n            && ! info.getTimeSettings().equals(m_timeSettings))\n        {\n            TimeSettings timeSettings = info.getTimeSettings();\n            m_game.setTimeSettings(timeSettings);\n            m_timeSettings = timeSettings;\n        }\n        setTitle();\n        updateViews(false);\n    }\n\n    public void actionGotoBookmark(int i)\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        if (i < 0 || i >= m_bookmarks.size())\n            return;\n        Bookmark bookmark = m_bookmarks.get(i);\n        if (! loadFile(bookmark.m_file, -1))\n            return;\n        updateViews(true);\n        String variation = bookmark.m_variation;\n        ConstNode node = getTree().getRootConst();\n        if (! variation.equals(\"\"))\n        {\n            node = NodeUtil.findByVariation(node, variation);\n            if (node == null)\n            {\n                showError(i18n(\"MSG_BOOKMARK_INVALID_VARIATION\"), \"\");\n                return;\n            }\n        }\n        node = NodeUtil.findByMoveNumber(node, bookmark.m_move);\n        if (node == null)\n        {\n            showError(i18n(\"MSG_BOOKMARK_INVALID_MOVE_NUMBER\"), \"\");\n            return;\n        }\n        actionGotoNode(node);\n    }\n\n    public void actionGotoMove()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node = MoveNumberDialog.show(this, getCurrentNode(),\n                                               m_messageDialogs);\n        if (node == null)\n            return;\n        actionGotoNode(node);\n    }\n\n    public void actionGotoNode(ConstNode node)\n    {\n        boolean protectGui = (m_gtp != null);\n        actionGotoNode(node, protectGui);\n    }\n\n    private void actionGotoNode(final ConstNode node, final boolean protectGui)\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (protectGui)\n            protectGui();\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    gotoNode(node);\n                    boardChangedBegin(false, false);\n                    if (protectGui)\n                        unprotectGui();\n                }\n            };\n        if (protectGui)\n            SwingUtilities.invokeLater(runnable);\n        else\n            runnable.run();\n    }\n\n    public void actionGotoVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node = GotoVariationDialog.show(this, getTree(),\n                                                  getCurrentNode(),\n                                                  m_messageDialogs);\n        if (node == null)\n            return;\n        actionGotoNode(node);\n    }\n\n    public void actionHandicap(int handicap)\n    {\n        if (! checkCommandInProgress())\n            return;\n        m_handicap = handicap;\n        if (isModified())\n            showInfo(i18n(\"MSG_HANDICAP_NEXT_GAME\"),\n                     i18n(\"MSG_HANDICAP_NEXT_GAME_2\"), true);\n        else\n        {\n            m_computerBlack = false;\n            m_computerWhite = false;\n            newGame(getBoardSize());\n            updateViews(true);\n        }\n    }\n\n    public void actionImportSgfFromClipboard()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        String text = GuiUtil.getClipboardText();\n        if (text == null)\n        {\n            showError(i18n(\"MSG_NO_TEXT_IN_CLIPBOARD\"), \"\", false);\n            return;\n        }\n        ByteArrayInputStream in = new ByteArrayInputStream(text.getBytes());\n        try\n        {\n            SgfReader reader = new SgfReader(in, null, null, 0);\n            GameTree tree = reader.getTree();\n            m_game.init(tree);\n        }\n        catch (SgfError e)\n        {\n            showError(i18n(\"MSG_IMPORT_FAILED\"), e);\n        }\n        m_guiBoard.initSize(getBoard().getSize());\n        initGtp();\n        m_computerBlack = false;\n        m_computerWhite = false;\n        boardChangedBegin(false, true);\n    }\n\n    public void actionImportTextPosition()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        File file = FileDialogs.showOpen(this, i18n(\"TIT_IMPORT_TEXT\"));\n        if (file == null)\n            return;\n        try\n        {\n            importTextPosition(new FileReader(file));\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_FILE_NOT_FOUND\"), \"\", false);\n        }\n    }\n\n    public void actionImportTextPositionFromClipboard()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        String text = GuiUtil.getClipboardText();\n        if (text == null)\n            showError(i18n(\"MSG_NO_TEXT_IN_CLIPBOARD\"), \"\", false);\n        else\n            importTextPosition(new StringReader(text));\n    }\n\n    public void actionInterrupt()\n    {\n        if (m_gtp == null || m_gtp.isProgramDead() || ! isCommandInProgress())\n            return;\n        if (m_interrupt.run(this, m_gtp, m_messageDialogs))\n        {\n            showStatus(i18n(\"STAT_INTERRUPT\"));\n            m_interruptComputerBoth = true;\n        }\n    }\n\n    public void actionKeepOnlyPosition()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! showQuestion(i18n(\"MSG_KEEP_ONLY_POSITION\"),\n                           i18n(\"MSG_KEEP_ONLY_POSITION_2\"),\n                           i18n(\"LB_DELETE\"), true))\n            return;\n        m_game.keepOnlyPosition();\n        initGtp();\n        boardChangedBegin(false, true);\n    }\n\n    public void actionMainWindowActivate()\n    {\n        requestFocus();\n    }\n\n    public void actionMakeMainVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        String disableKey = \"net.sf.gogui.gogui.GoGui.make-main-variation\";\n        if (! m_messageDialogs.showQuestion(disableKey, this,\n                                            i18n(\"MSG_MAKE_MAIN_VAR\"),\n                                            i18n(\"MSG_MAKE_MAIN_VAR_2\"),\n                                            i18n(\"LB_MAKE_MAIN_VAR\"), false))\n            return;\n        m_game.makeMainVariation();\n        boardChangedBegin(false, true);\n    }\n\n    public void actionMark(GoPoint point, MarkType type, boolean mark)\n    {\n        if (mark)\n            m_game.addMarked(point, type);\n        else\n            m_game.removeMarked(point, type);\n        if (type == MarkType.MARK)\n            m_guiBoard.setMark(point, mark);\n        else if (type == MarkType.CIRCLE)\n            m_guiBoard.setMarkCircle(point, mark);\n        else if (type == MarkType.SQUARE)\n            m_guiBoard.setMarkSquare(point, mark);\n        else if (type == MarkType.TRIANGLE)\n            m_guiBoard.setMarkTriangle(point, mark);\n        updateViews(false);\n    }\n\n    public void actionNewGame()\n    {\n        actionNewGame(getBoardSize());\n    }\n\n    public void actionNewGame(int size)\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        setFile(null);\n        newGame(size);\n        if (m_gtp != null && ! m_gtp.isGenmoveSupported())\n        {\n            m_computerBlack = false;\n            m_computerWhite = false;\n        }\n        else if (m_computerBlack || m_computerWhite)\n        {\n            // Set computer color to the color not to move to avoid automatic\n            // move generation after starting a new game\n            if (m_handicap == 0)\n            {\n                m_computerBlack = false;\n                m_computerWhite = true;\n            }\n            else\n            {\n                m_computerBlack = true;\n                m_computerWhite = false;\n            }\n        }\n        boardChangedBegin(true, true);\n    }\n\n    public void actionNewProgram()\n    {\n        m_newProgram = new Program(\"\", \"\", \"\", \"\", \"\");\n        final ProgramEditor editor = new ProgramEditor();\n        m_newProgram =\n            editor.editItem(this, i18n(\"TIT_NEW_PROGRAM\"), m_newProgram, true,\n                            false, m_messageDialogs);\n        if (m_newProgram == null)\n            return;\n        protectGui();\n        SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    attachNewProgram(m_newProgram.m_command, m_newProgram);\n                    unprotectGui();\n                    if (m_gtp == null || m_gtp.isProgramDead())\n                    {\n                        m_newProgram = editor.editItem(GoGui.this,\n                                                       i18n(\"TIT_NEW_PROGRAM\"),\n                                                       m_newProgram, true,\n                                                       false,\n                                                       m_messageDialogs);\n                        if (m_newProgram == null)\n                            return;\n                        SwingUtilities.invokeLater(this);\n                        return;\n                    }\n                    m_newProgram.m_name = m_gtp.getLabel();\n                    m_newProgram.m_version = m_version;\n                    m_newProgram.setUniqueLabel(m_programs);\n                    m_newProgram = editor.editItem(GoGui.this,\n                                                   i18n(\"TIT_NEW_PROGRAM\"),\n                                                   m_newProgram, false, true,\n                                                   m_messageDialogs);\n                    if (m_newProgram == null)\n                    {\n                        actionDetachProgram();\n                        return;\n                    }\n                    m_programs.add(m_newProgram);\n                    m_program = m_newProgram;\n                    m_prefs.putInt(\"program\", m_programs.size() - 1);\n                    m_menuBar.setPrograms(m_programs);\n                    Program.save(m_programs);\n                    updateViews(false);\n                }\n            });\n    }\n\n    public void actionNextEarlierVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node = NodeUtil.getNextEarlierVariation(getCurrentNode());\n        if (node != null)\n            actionGotoNode(node);\n    }\n\n    public void actionNextVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node = NodeUtil.getNextVariation(getCurrentNode());\n        if (node != null)\n            actionGotoNode(node);\n    }\n\n    public void actionOpen()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        File file = FileDialogs.showOpenSgf(this);\n        if (file == null)\n            return;\n        actionOpenFile(file);\n    }\n\n    public void actionOpenFile(final File file)\n    {\n        if (file == null)\n            return;\n        if (! checkStateChangePossible())\n            return;\n        if (! checkSaveGame())\n            return;\n        final boolean protectGui = (m_gtp != null);\n        if (protectGui)\n            protectGui();\n        SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    loadFile(file, -1);\n                    boardChangedBegin(false, true);\n                    if (protectGui)\n                        unprotectGui();\n                }\n            });\n    }\n\n    public void actionPass()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! showOptionalQuestion(\"pass\", i18n(\"MSG_PASS\"),\n                                   i18n(\"MSG_PASS_2\"), i18n(\"LB_PASS\"), false))\n            return;\n        humanMoved(Move.getPass(getToMove()));\n    }\n\n    public void actionPlay(boolean isSingleMove)\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! synchronizeProgram())\n            return;\n        if (! isSingleMove && ! isComputerBoth())\n        {\n            m_computerBlack = false;\n            m_computerWhite = false;\n            if (getToMove() == BLACK)\n                m_computerBlack = true;\n            else\n                m_computerWhite = true;\n        }\n        generateMove(isSingleMove);\n        m_game.startClock();\n    }\n\n    public void actionPreviousEarlierVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node =\n            NodeUtil.getPreviousEarlierVariation(getCurrentNode());\n        if (node != null)\n            actionGotoNode(node);\n    }\n\n    public void actionPreviousVariation()\n    {\n        if (! checkStateChangePossible())\n            return;\n        ConstNode node = NodeUtil.getPreviousVariation(getCurrentNode());\n        if (node != null)\n            actionGotoNode(node);\n    }\n\n    public void actionPrint()\n    {\n        Print.run(this, m_guiBoard, m_messageDialogs);\n    }\n\n    public void actionReattachProgram()\n    {\n        if (m_gtp == null)\n            return;\n        if (! checkCommandInProgress())\n            return;\n        protectGui();\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    try\n                    {\n                        attachNewProgram(m_programCommand, m_program);\n                    }\n                    finally\n                    {\n                        unprotectGui();\n                    }\n                }\n            };\n        SwingUtilities.invokeLater(runnable);\n    }\n\n    public void actionReattachWithParameters()\n    {\n        if (m_gtp == null)\n            return;\n        if (! checkCommandInProgress())\n            return;\n        final boolean fromSnapshot =\n            (isProgramDead() && m_parameterSnapshot != null);\n        if (! fromSnapshot)\n        {\n            if (! checkHasParameterCommands())\n                return;\n        }\n        protectGui();\n        Runnable runnable = new Runnable() {\n                public void run() {\n                    try\n                    {\n                        File file;\n                        if (fromSnapshot)\n                            file = m_parameterSnapshot;\n                        else\n                        {\n                            try\n                            {\n                                file = File.createTempFile(\"gogui-param\",\n                                                           \".gtp\");\n                            }\n                            catch (IOException e)\n                            {\n                                showError(i18n(\"MSG_PARAM_TMP_FILE_ERROR\"), e);\n                                return;\n                            }\n                            if (! saveParameters(file))\n                                return;\n                        }\n                        if (! attachNewProgram(m_programCommand, m_program))\n                            return;\n                        sendGtpFile(file);\n                    }\n                    finally\n                    {\n                        unprotectGui();\n                    }\n                }\n            };\n        SwingUtilities.invokeLater(runnable);\n    }\n\n    public void actionRestoreParameters()\n    {\n        if (m_gtp == null)\n            return;\n        if (! checkCommandInProgress())\n            return;\n        if (m_parameterSnapshot == null)\n            return;\n        sendGtpFile(m_parameterSnapshot);\n    }\n\n    public void actionSave()\n    {\n        if (! isModified())\n            return;\n        if (m_gameFile == null)\n            actionSaveAs();\n        else\n        {\n            File file = m_gameFile.m_file;\n            if (file.exists())\n            {\n                String mainMessage = format(i18n(\"MSG_REPLACE_FILE\"),\n                                            file.getName());\n                String optionalMessage = i18n(\"MSG_REPLACE_FILE_2\");\n                String disableKey = \"net.sf.gogui.GoGui.overwrite\";\n                if (! m_messageDialogs.showQuestion(disableKey, this,\n                                                    mainMessage,\n                                                    optionalMessage,\n                                                    i18n(\"LB_REPLACE_FILE\"),\n                                                    true))\n                    return;\n            }\n            save(m_gameFile);\n        }\n        updateViews(false);\n    }\n\n    public void actionSaveAs()\n    {\n        saveDialog();\n        updateViews(false);\n    }\n\n    public void actionSaveCommands()\n    {\n        if (m_shell == null)\n            return;\n        m_shell.saveCommands(this);\n    }\n\n    public void actionSaveLog()\n    {\n        if (m_shell == null)\n            return;\n        m_shell.saveLog(this);\n    }\n\n    public void actionSaveParameters()\n    {\n        if (m_gtp == null)\n            return;\n        if (! checkHasParameterCommands())\n            return;\n        File file = showSave(i18n(\"TIT_SAVE_PARAM\"));\n        if (file == null)\n            return;\n        saveParameters(file);\n    }\n\n    public void actionSnapshotParameters()\n    {\n        if (m_gtp == null)\n            return;\n        if (! checkCommandInProgress())\n            return;\n        if (! checkHasParameterCommands())\n            return;\n        if (m_parameterSnapshot == null)\n            try\n            {\n                m_parameterSnapshot =\n                    File.createTempFile(\"gogui-param\", \".gtp\");\n            }\n            catch (IOException e)\n            {\n                showError(i18n(\"MSG_PARAM_TMP_FILE_ERROR\"), e);\n                return;\n            }\n        saveParameters(m_parameterSnapshot);\n        updateViews(false);\n    }\n\n    public void actionScore()\n    {\n        if (m_scoreMode)\n            return;\n        if (! checkStateChangePossible())\n            return;\n        boolean programReady = (m_gtp != null && synchronizeProgram());\n        if (m_gtp == null || ! programReady)\n        {\n            String disableKey = \"net.sf.gogui.gogui.GoGui.score-no-program\";\n            String optionalMessage;\n            if (m_gtp == null)\n                optionalMessage = \"MSG_SCORE_NO_PROGRAM\";\n            else\n                optionalMessage = \"MSG_SCORE_CANNOT_USE_PROGRAM\";\n            m_messageDialogs.showInfo(disableKey, this,\n                                      i18n(\"MSG_SCORE_MANUAL\"),\n                                      i18n(optionalMessage), true);\n            updateViews(false);\n            initScore(null);\n            return;\n        }\n        if (m_gtp.isSupported(\"final_status_list\"))\n        {\n            Runnable callback = new Runnable() {\n                    public void run() {\n                        scoreContinue();\n                    }\n                };\n            runLengthyCommand(\"final_status_list dead\", callback);\n        }\n        else\n        {\n            String disableKey =\n                \"net.sf.gogui.gogui.GoGui.score-not-supported\";\n            String optionalMessage;\n            String name = getProgramName();\n            optionalMessage = format(i18n(\"MSG_SCORE_NO_SUPPORT\"), name);\n            m_messageDialogs.showInfo(disableKey, this,\n                                      i18n(\"MSG_SCORE_MANUAL\"),\n                                      optionalMessage, true);\n            updateViews(false);\n            initScore(null);\n        }\n    }\n\n    public void actionScoreDone(Score score)\n    {\n        if (! m_scoreMode)\n            return;\n        scoreDone(score);\n        updateViews(false);\n    }\n\n    public void actionSendCommand(String command, final boolean isCritical,\n                                  final boolean showError)\n    {\n        if (! checkCommandInProgress())\n            return;\n        if (GtpUtil.isStateChangingCommand(command))\n        {\n            showError(i18n(\"MSG_BOARD_CHANGING_COMMAND\"), \"\", false);\n            return;\n        }\n        if (! synchronizeProgram())\n            return;\n        Runnable callback = new Runnable() {\n                public void run() {\n                    endLengthyCommand(isCritical, showError);\n                }\n            };\n        m_gtp.send(command, callback);\n        beginLengthyCommand();\n    }\n\n    public void actionSendFile()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (m_shell == null)\n            return;\n        File file = FileDialogs.showOpen(this, i18n(\"TIT_CHOOSE_GTP_FILE\"));\n        if (file == null)\n            return;\n        actionSendFile(file);\n    }\n\n    public void actionSendFile(File file)\n    {\n        if (file == null)\n            return;\n        if (! checkStateChangePossible())\n            return;\n        if (m_shell == null)\n            return;\n        if (! synchronizeProgram())\n            return;\n        sendGtpFile(file);\n        m_menuBar.addRecentGtp(file);\n        updateViews(false);\n    }\n\n    public void actionSetAnalyzeCommand(AnalyzeCommand command)\n    {\n        actionSetAnalyzeCommand(command, false, true, true, false);\n    }\n\n    public void actionSetAnalyzeCommand(AnalyzeCommand command,\n                                        boolean autoRun, boolean clearBoard,\n                                        boolean oneRunOnly,\n                                        boolean reuseTextWindow)\n    {\n        if (! synchronizeProgram())\n            return;\n        if (! checkStateChangePossible())\n            return;\n        initAnalyzeCommand(command, autoRun, clearBoard, reuseTextWindow);\n        m_analyzeOneRunOnly = oneRunOnly;\n        boolean needsPointArg = m_analyzeCommand.needsPointArg();\n        if (needsPointArg && ! m_analyzeCommand.isPointArgMissing())\n        {\n            m_guiBoard.clearAllSelect();\n            m_guiBoard.setSelect(m_analyzeCommand.getPointArg(), true);\n        }\n        else if (needsPointArg || m_analyzeCommand.needsPointListArg())\n        {\n            m_guiBoard.clearAllSelect();\n            if (m_analyzeCommand.getType() == AnalyzeType.EPLIST)\n                GuiBoardUtil.setSelect(m_guiBoard,\n                                       m_analyzeCommand.getPointListArg(),\n                                       true);\n            toFront();\n            return;\n        }\n        analyzeBegin(false);\n    }\n\n    public void actionSetShowVariations(ShowVariations mode)\n    {\n        m_showVariations = mode;\n        m_prefs.putInt(\"show-variations\", m_showVariations.ordinal());\n        resetBoard();\n        updateViews(false);\n    }\n\n    public void actionSetTimeLeft()\n    {\n        TimeLeftDialog.show(this, m_game, getCurrentNode(), m_messageDialogs);\n        updateViews(false);\n    }\n\n    public void actionSetup(GoColor color)\n    {\n        assert color.isBlackWhite();\n        if (! checkCommandInProgress())\n            return;\n        if (m_scoreMode)\n            scoreDone(null);\n        ConstNode node = getCurrentNode();\n        if (m_setupMode)\n        {\n            if (color == m_setupColor)\n            {\n                setupDone();\n                boardChangedBegin(false, true);\n            }\n            else\n                m_setupColor = color;\n            updateViews(false);\n        }\n        else\n        {\n            resetBoard();\n            m_setupMode = true;\n            m_setupColor = color;\n            m_setupNodeCreated = (node.getMove() != null || node.hasChildren());\n            if (m_setupNodeCreated)\n            {\n                m_game.createNewChild();\n                currentNodeChanged();\n                updateViews(true);\n            }\n            else\n                updateViews(false);\n        }\n        if (m_setupMode)\n        {\n            if (m_setupColor == BLACK)\n                showStatus(i18n(\"STAT_SETUP_BLACK\"));\n            else\n                showStatus(i18n(\"STAT_SETUP_WHITE\"));\n        }\n    }\n\n    public void actionShowAnalyzeDialog()\n    {\n        if (m_gtp == null)\n            return;\n        if (m_analyzeDialog == null)\n            createAnalyzeDialog();\n        else\n            m_analyzeDialog.toFront();\n    }\n\n    public void actionShowShell()\n    {\n        showShell();\n    }\n\n    public void actionShowTree()\n    {\n        if (m_gameTreeViewer == null)\n        {\n            createTree();\n            updateViews(false);\n        }\n        else\n            m_gameTreeViewer.toFront();\n    }\n\n    public void actionToggleBeepAfterMove()\n    {\n        m_beepAfterMove = ! m_beepAfterMove;\n        m_prefs.putBoolean(\"beep-after-move\", m_beepAfterMove);\n    }\n\n    public void actionToggleAutoNumber()\n    {\n        m_autoNumber = ! m_autoNumber;\n        if (m_gtp != null)\n            m_gtp.setAutoNumber(m_autoNumber);\n    }\n\n    public void actionToggleCommentMonoFont()\n    {\n        boolean monoFont = ! m_comment.getMonoFont();\n        m_comment.setMonoFont(monoFont);\n        m_prefs.putBoolean(\"comment-font-fixed\", monoFont);\n    }\n\n    public void actionToggleCompletion()\n    {\n        m_commandCompletion = ! m_commandCompletion;\n        if (m_shell != null)\n            m_shell.setCommandCompletion(m_commandCompletion);\n        m_prefs.putBoolean(\"gtpshell-disable-completions\",\n                           ! m_commandCompletion);\n    }\n\n    public void actionToggleShowCursor()\n    {\n        boolean showCursor = ! m_guiBoard.getShowCursor();\n        m_guiBoard.setShowCursor(showCursor);\n        m_prefs.putBoolean(\"show-cursor\", showCursor);\n    }\n\n    public void actionToggleShowGrid()\n    {\n        boolean showGrid = ! m_guiBoard.getShowGrid();\n        m_guiBoard.setShowGrid(showGrid);\n        m_prefs.putBoolean(\"show-grid\", showGrid);\n    }\n\n    public void actionToggleShowInfoPanel()\n    {\n        if (GuiUtil.isNormalSizeMode(this))\n        {\n            if (m_showInfoPanel)\n                m_comment.setPreferredSize(m_comment.getSize());\n            m_guiBoard.setPreferredFieldSize(m_guiBoard.getFieldSize());\n        }\n        showInfoPanel(! m_showInfoPanel);\n        updateViews(false);\n    }\n\n    public void actionToggleShowLastMove()\n    {\n        m_showLastMove = ! m_showLastMove;\n        m_prefs.putBoolean(\"show-last-move\", m_showLastMove);\n        updateFromGoBoard();\n        updateViews(false);\n    }\n\n    public void actionToggleShowMoveNumbers()\n    {\n        if (m_showMoveNumbers)\n            m_guiBoard.clearAllLabels();\n        m_showMoveNumbers = ! m_showMoveNumbers;\n        m_prefs.putBoolean(\"show-move-numbers\", m_showMoveNumbers);\n        updateFromGoBoard();\n        updateViews(false);\n    }\n\n    public void actionToggleShowSubtreeSizes()\n    {\n        m_showSubtreeSizes = ! m_showSubtreeSizes;\n        m_prefs.putBoolean(\"gametree-show-subtree-sizes\", m_showSubtreeSizes);\n        if (m_gameTreeViewer == null)\n            updateViews(false);\n        else\n        {\n            m_gameTreeViewer.setShowSubtreeSizes(m_showSubtreeSizes);\n            updateViews(true);\n        }\n    }\n\n    public void actionToggleShowToolbar()\n    {\n        if (GuiUtil.isNormalSizeMode(this))\n        {\n            if (m_showInfoPanel)\n                m_comment.setPreferredSize(m_comment.getSize());\n            m_guiBoard.setPreferredFieldSize(m_guiBoard.getFieldSize());\n        }\n        showToolbar(! m_showToolbar);\n        updateViews(false);\n    }\n\n    public void actionToggleTimeStamp()\n    {\n        m_timeStamp = ! m_timeStamp;\n        if (m_shell != null)\n            m_shell.setTimeStamp(m_timeStamp);\n        m_prefs.putBoolean(\"gtpshell-timestamp\", m_timeStamp);\n        updateViews(false);\n    }\n\n    public void actionTreeLabels(GameTreePanel.Label mode)\n    {\n        m_treeLabels = mode;\n        m_prefs.putInt(\"gametree-labels\", mode.ordinal());\n        if (m_gameTreeViewer == null)\n            updateViews(false);\n        else\n        {\n            m_gameTreeViewer.setLabelMode(mode);\n            updateViews(true);\n        }\n    }\n\n    public void actionTreeSize(GameTreePanel.Size mode)\n    {\n        m_treeSize = mode;\n        m_prefs.putInt(\"gametree-size\", mode.ordinal());\n        if (m_gameTreeViewer == null)\n            updateViews(false);\n        else\n        {\n            m_gameTreeViewer.setSizeMode(mode);\n            updateViews(true);\n        }\n    }\n\n    public void actionTruncate()\n    {\n        if (! checkStateChangePossible())\n            return;\n        if (! getCurrentNode().hasFather())\n            return;\n        String disableKey = \"net.sf.gogui.gogui.GoGui.truncate\";\n        if (! m_messageDialogs.showQuestion(disableKey, this,\n                                            i18n(\"MSG_TRUNCATE\"),\n                                            i18n(\"MSG_TRUNCATE_2\"),\n                                            i18n(\"LB_TRUNCATE\"), false))\n            return;\n        m_game.truncate();\n        actionGotoNode(getCurrentNode());\n        boardChangedBegin(false, true);\n    }\n\n    public void actionTruncateChildren()\n    {\n        if (! checkStateChangePossible())\n            return;\n        int numberChildren = getCurrentNode().getNumberChildren();\n        if (numberChildren == 0)\n            return;\n        String disableKey = \"net.sf.gogui.gogui.GoGui.truncate-children\";\n        if (! m_messageDialogs.showQuestion(disableKey, this,\n                                            i18n(\"MSG_TRUNCATE_CHILDREN\"),\n                                            i18n(\"MSG_TRUNCATE_CHILDREN_2\"),\n                                            i18n(\"LB_TRUNCATE\"), false))\n            return;\n        m_game.truncateChildren();\n        boardChangedBegin(false, true);\n    }\n\n    public void actionQuit()\n    {\n        close();\n    }\n\n    public boolean getAutoNumber()\n    {\n        return m_autoNumber;\n    }\n\n    public boolean getBeepAfterMove()\n    {\n        return m_beepAfterMove;\n    }\n\n    public boolean getCommentMonoFont()\n    {\n        return m_comment.getMonoFont();\n    }\n\n    public boolean getCompletion()\n    {\n        return m_commandCompletion;\n    }\n\n    /** Get name of currently attached program.\n        @return Name or null, if no program is attached or name is not\n        known. */\n    public String getProgramName()\n    {\n        String name = null;\n        if (m_gtp != null)\n            name = m_gtp.getName();\n        if (name == null)\n            name = i18n(\"MSG_UNKNOWN_PROGRAM_NAME\");\n        return name;\n    }\n\n    public int getNumberPrograms()\n    {\n        return m_programs.size();\n    }\n\n    /** Get label for currently attached program.\n        @return Label from Program instance, if program was created with a\n        Program instance, otherwise label as in GtpClientBase#getLabel; null\n        if no program is attached. */\n    public String getProgramLabel()\n    {\n        if (m_gtp == null)\n            return null;\n        else if (m_program != null && ! StringUtil.isEmpty(m_program.m_label))\n            return m_program.m_label;\n        else\n            return m_gtp.getLabel();\n    }\n\n    public GoColor getSetupColor()\n    {\n        return m_setupColor;\n    }\n\n    public boolean getShowLastMove()\n    {\n        return m_showLastMove;\n    }\n\n    public boolean getShowMoveNumbers()\n    {\n        return m_showMoveNumbers;\n    }\n\n    public boolean getShowSubtreeSizes()\n    {\n        return m_showSubtreeSizes;\n    }\n\n    public ShowVariations getShowVariations()\n    {\n        return m_showVariations;\n    }\n\n    public boolean getTimeStamp()\n    {\n        return m_timeStamp;\n    }\n\n    public GameTreePanel.Label getTreeLabels()\n    {\n        return m_treeLabels;\n    }\n\n    public GameTreePanel.Size getTreeSize()\n    {\n        return m_treeSize;\n    }\n\n    /** Return whether the currently attached program has analyze commands of\n        type \"param\". */\n    public boolean hasParameterCommands()\n    {\n        if (m_analyzeCommands == null)\n            return false;\n        return AnalyzeUtil.hasParameterCommands(m_analyzeCommands);\n    }\n\n    public boolean hasParameterSnapshot()\n    {\n        return m_parameterSnapshot != null;\n    }\n\n    public boolean isAnalyzeDialogShown()\n    {\n        return (m_analyzeDialog != null);\n    }\n\n    public boolean isCommandInProgress()\n    {\n        return (m_gtp != null && m_gtp.isCommandInProgress());\n    }\n\n    /** Check if computer plays a color (or both). */\n    public boolean isComputerColor(GoColor color)\n    {\n        if (color == BLACK)\n            return m_computerBlack;\n        assert color == WHITE;\n        return m_computerWhite;\n    }\n\n    public boolean isInfoPanelShown()\n    {\n        return m_showInfoPanel;\n    }\n\n    public boolean isShellShown()\n    {\n        return (m_shell != null && m_shell.isVisible());\n    }\n\n    public boolean isToolbarShown()\n    {\n        return m_showToolbar;\n    }\n\n    public boolean isTreeShown()\n    {\n        return (m_gameTreeViewer != null);\n    }\n\n    public void contextMenu(GoPoint point, Component invoker, int x, int y)\n    {\n        if (m_setupMode\n            || (m_analyzeCommand != null\n                && m_analyzeCommand.needsPointListArg()))\n        {\n            fieldClicked(point, true);\n            return;\n        }\n        ContextMenu contextMenu = createContextMenu(point);\n        contextMenu.show(invoker, x, y);\n    }\n\n    public void fieldClicked(GoPoint p, boolean modifiedSelect)\n    {\n        if (m_setupMode)\n        {\n            if (! checkCommandInProgress())\n                return;\n            GoColor color;\n            if (modifiedSelect)\n                color = m_setupColor.otherColor();\n            else\n                color = m_setupColor;\n            if (getBoard().getColor(p) == color)\n                color = EMPTY;\n            setup(p, color);\n            updateViews(false);\n        }\n        else if (m_analyzeCommand != null && m_analyzeCommand.needsPointArg()\n                 && ! modifiedSelect)\n        {\n            if (! checkCommandInProgress())\n                return;\n            m_analyzeCommand.setPointArg(p);\n            m_guiBoard.clearAllSelect();\n            m_guiBoard.setSelect(p, true);\n            analyzeBegin(false);\n        }\n        else if (m_analyzeCommand != null\n                 && m_analyzeCommand.needsPointListArg())\n        {\n            if (! checkCommandInProgress())\n                return;\n            PointList pointListArg = m_analyzeCommand.getPointListArg();\n            if (pointListArg.contains(p))\n            {\n                pointListArg.remove(p);\n                if (modifiedSelect)\n                    pointListArg.add(p);\n            }\n            else\n                pointListArg.add(p);\n            m_guiBoard.clearAllSelect();\n            GuiBoardUtil.setSelect(m_guiBoard, pointListArg, true);\n            if (modifiedSelect && pointListArg.size() > 0)\n                analyzeBegin(false);\n        }\n        else if (m_scoreMode && ! modifiedSelect)\n        {\n            if (! checkCommandInProgress())\n                return;\n            GuiBoardUtil.scoreSetDead(m_guiBoard, m_countScore, getBoard(), p);\n            Komi komi = getGameInfo().getKomi();\n            m_scoreDialog.showScore(m_countScore, komi);\n        }\n        else if (modifiedSelect)\n            m_guiBoard.contextMenu(p);\n        else\n        {\n            if (getBoard().getColor(p) != EMPTY)\n                return;\n            if (! checkCommandInProgress())\n                return;\n            if (getBoard().isSuicide(getToMove(), p)\n                && ! showQuestion(i18n(\"MSG_SUICIDE\"), i18n(\"MSG_SUICIDE_2\"),\n                                  i18n(\"LB_SUICIDE\"),false))\n                return;\n            else if (getBoard().isKo(p)\n                     && ! showQuestion(i18n(\"MSG_ILLEGAL_KO\"),\n                                       i18n(\"MSG_ILLEGAL_KO_2\"),\n                                       i18n(\"LB_ILLEGAL_KO\"), false))\n                return;\n            Move move = Move.get(getToMove(), p);\n            humanMoved(move);\n        }\n    }\n\n    public GoGuiActions getActions()\n    {\n        return m_actions;\n    }\n\n    public File getFile()\n    {\n        if (m_gameFile == null)\n            return null;\n        return m_gameFile.m_file;\n    }\n\n    public ConstGame getGame()\n    {\n        return m_game;\n    }\n\n    public ConstGuiBoard getGuiBoard()\n    {\n        return m_guiBoard;\n    }\n\n    public int getHandicapDefault()\n    {\n        return m_handicap;\n    }\n\n    public boolean getMonoFont()\n    {\n        return m_comment.getMonoFont();\n    }\n\n    /** Get currently used pattern for search in comments. */\n    public Pattern getPattern()\n    {\n        return m_pattern;\n    }\n\n    public boolean isInSetupMode()\n    {\n        return m_setupMode;\n    }\n\n    /** Callback for selected text.\n        This is a callback for text selection exents in different components.\n        It parses the text for valid points and marks them on the board. */\n    public void textSelected(String text)\n    {\n        if (text == null)\n            text = \"\";\n        PointList points = GtpUtil.parsePointString(text, getBoardSize());\n        GuiBoardUtil.showPointList(m_guiBoard, points);\n    }\n\n    public void initAnalyzeCommand(AnalyzeCommand command, boolean autoRun,\n                                   boolean clearBoard, boolean reuseTextWindow)\n    {\n        if (! synchronizeProgram())\n            return;\n        m_analyzeCommand = command;\n        m_analyzeAutoRun = autoRun;\n        m_analyzeClearBoard = clearBoard;\n        m_analyzeReuseTextWindow = reuseTextWindow;\n        if (command.needsPointArg())\n        {\n            setBoardCursor(Cursor.HAND_CURSOR);\n            showStatusSelectTarget();\n        }\n        else if (command.needsPointListArg())\n        {\n            setBoardCursor(Cursor.HAND_CURSOR);\n            showStatusSelectPointList();\n        }\n    }\n\n    public boolean isInterruptSupported()\n    {\n        return (m_gtp != null && m_gtp.isInterruptSupported());\n    }\n\n    public boolean isModified()\n    {\n        return m_game.isModified();\n    }\n\n    /** Return if a program is currently attached.\n        Also returns true, if a program is attached but dead, which can be\n        checked with isProgramDead() */\n    public boolean isProgramAttached()\n    {\n        return (m_gtp != null);\n    }\n\n    public boolean isProgramDead()\n    {\n        return (m_gtp != null && m_gtp.isProgramDead());\n    }\n\n    public void showLiveGfx(String text)\n    {\n        assert SwingUtilities.isEventDispatchThread();\n        // The live gfx events can arrive delayed, we don't want to allow\n        // them to paint on the board, if no command is currently running\n        if (! isCommandInProgress())\n            return;\n        m_guiBoard.clearAll();\n        GuiBoardUtil.updateFromGoBoard(m_guiBoard, getBoard(), false, false);\n        AnalyzeShow.showGfx(text, m_guiBoard, m_statusBar, null);\n    }\n\n    private class AnalyzeContinue\n        implements Runnable\n    {\n        public AnalyzeContinue(boolean checkComputerMove)\n        {\n            m_checkComputerMove = checkComputerMove;\n        }\n\n        public void run()\n        {\n            analyzeContinue(m_checkComputerMove);\n        }\n\n        private final boolean m_checkComputerMove;\n    }\n\n    private class ShowInvalidResponse\n        implements Runnable\n    {\n        public ShowInvalidResponse(String line)\n        {\n        }\n\n        public void run()\n        {\n            String name = getProgramName();\n            String mainMessage = format(i18n(\"MSG_INVALID_RESPONSE\"), name);\n            String disableKey = \"net.sf.gogui.gogui.GoGui.invalid-response\";\n            String optionalMessage =\n                format(i18n(\"MSG_INVALID_NOSTATUS_RESPONSE\"), name);\n            m_messageDialogs.showWarning(disableKey, GoGui.this, mainMessage,\n                                         optionalMessage, true);\n        }\n    }\n\n    private static class LoadFileRunnable\n        implements GuiUtil.ProgressRunnable\n    {\n        public LoadFileRunnable(File file)\n        {\n            m_file = file;\n        }\n\n        public GameTree getTree()\n        {\n            return m_reader.getTree();\n        }\n\n        public String getWarnings()\n        {\n            return m_reader.getWarnings();\n        }\n\n        public GameFile getGameFile()\n        {\n            return m_reader.getFile();\n        }\n\n        public void run(ProgressShow progressShow) throws Throwable\n        {\n            m_reader = new GameReader(m_file, progressShow);\n        }\n\n        private final File m_file;\n\n        private GameReader m_reader;\n    }\n\n    private boolean m_analyzeAutoRun;\n\n    private boolean m_analyzeClearBoard;\n\n    private boolean m_analyzeOneRunOnly;\n\n    private boolean m_analyzeReuseTextWindow;\n\n    private boolean m_autoNumber;\n\n    private boolean m_commandCompletion;\n\n    /** Automatically register program in Program menu if GoGui was invoked\n        with the option -program */\n    private final boolean m_register;\n\n    private boolean m_timeStamp;\n\n    private final boolean m_auto;\n\n    private boolean m_beepAfterMove;\n\n    private boolean m_computerBlack;\n\n    private boolean m_computerWhite;\n\n    /** State variable used between generateMove and computerMoved.\n        Flag is set in actionInterrupt. */\n    private boolean m_interruptComputerBoth;\n\n    /** State variable used between generateMove and computerMoved. */\n    private boolean m_isSingleMove;\n\n    private boolean m_lostOnTimeShown;\n\n    private boolean m_resigned;\n\n    private boolean m_scoreMode;\n\n    private boolean m_setupMode;\n\n    private boolean m_showInfoPanel;\n\n    private boolean m_showLastMove;\n\n    private boolean m_showMoveNumbers;\n\n    private boolean m_showSubtreeSizes;\n\n    private boolean m_showToolbar;\n\n    private ShowVariations m_showVariations;\n\n    private boolean m_setupNodeCreated;\n\n    private final boolean m_verbose;\n\n    private int m_handicap;\n\n    private final int m_move;\n\n    private GameTreePanel.Label m_treeLabels;\n\n    private GameTreePanel.Size m_treeSize;\n\n    private final GuiBoard m_guiBoard;\n\n    private GuiGtpClient m_gtp;\n\n    private final Comment m_comment;\n\n    private final Interrupt m_interrupt = new Interrupt();\n\n    /** File corresponding to the current game. */\n    private GameFile m_gameFile;\n\n    private File m_initialFile;\n\n    private final GameInfoPanel m_gameInfoPanel;\n\n    private GtpShell m_shell;\n\n    private GameTreeViewer m_gameTreeViewer;\n\n    private Help m_help;\n\n    private final JPanel m_infoPanel;\n\n    private final JPanel m_innerPanel;\n\n    private final JSplitPane m_splitPane;\n\n    private final GoGuiMenuBar m_menuBar;\n\n    private final Game m_game;\n\n    private GoColor m_setupColor;\n\n    private final MessageDialogs m_messageDialogs = new MessageDialogs();\n\n    private Pattern m_pattern;\n\n    private final File m_analyzeCommandsFile;\n\n    private AnalyzeCommand m_analyzeCommand;\n\n    private final Session m_session =\n        new Session(\"net/sf/gogui/gogui/session\");\n\n    private final CountScore m_countScore = new CountScore();\n\n    private final StatusBar m_statusBar;\n\n    private final String m_gtpCommand;\n\n    private final String m_gtpFile;\n\n    private String m_lastAnalyzeCommand;\n\n    private String m_programCommand;\n\n    private String m_titleFromProgram;\n\n    private String m_version = \"\";\n\n    private AnalyzeDialog m_analyzeDialog;\n\n    private final Preferences m_prefs =\n        Preferences.userNodeForPackage(getClass());\n\n    private ScoreDialog m_scoreDialog;\n\n    private ArrayList<AnalyzeDefinition> m_analyzeCommands;\n\n    /** Program information.\n        Can be null even if a program is attached, if only m_programName\n        is known. */\n    private Program m_program;\n\n    /** Program currently being edited in actionNewProgram() */\n    private Program m_newProgram;\n\n    private final ThumbnailCreator m_thumbnailCreator =\n        new ThumbnailCreator(false);\n\n    private TimeSettings m_timeSettings;\n\n    private final GoGuiActions m_actions = new GoGuiActions(this);\n\n    private final GoGuiToolBar m_toolBar;\n\n    private ArrayList<Bookmark> m_bookmarks;\n\n    private ArrayList<Program> m_programs;\n\n    private ShowAnalyzeText m_showAnalyzeText;\n\n    /** Snapshot used in actionSnapshotParameters and actionRestoreParameters. */\n    private File m_parameterSnapshot;\n\n    private void analyzeBegin(boolean checkComputerMove)\n    {\n        if (m_gtp == null || m_analyzeCommand == null\n            || m_analyzeCommand.isPointArgMissing()\n            || ! synchronizeProgram())\n            return;\n        GoColor toMove = getToMove();\n        m_lastAnalyzeCommand = m_analyzeCommand.replaceWildCards(toMove);\n        runLengthyCommand(m_lastAnalyzeCommand,\n                          new AnalyzeContinue(checkComputerMove));\n        showStatus(format(i18n(\"STAT_RUNNING\"),\n                          m_analyzeCommand.getResultTitle()));\n    }\n\n    private void analyzeContinue(boolean checkComputerMove)\n    {\n        if (m_analyzeClearBoard)\n            resetBoard();\n        boolean isCritical = (m_gtp != null && m_gtp.isProgramDead());\n        if (! endLengthyCommand(isCritical))\n            return;\n        clearStatus();\n        if (m_analyzeCommand == null)\n        {\n            // Program was detached while running the analyze command\n            resetBoard();\n            return;\n        }\n        String title = m_analyzeCommand.getResultTitle();\n        try\n        {\n            String response = m_gtp.getResponse();\n            StringBuilder showTextBuffer = new StringBuilder(256);\n            AnalyzeShow.show(m_analyzeCommand, m_guiBoard, m_statusBar,\n                             getBoard(), response, showTextBuffer);\n            AnalyzeType type = m_analyzeCommand.getType();\n            GoPoint pointArg = null;\n            if (m_analyzeCommand.needsPointArg())\n                pointArg = m_analyzeCommand.getPointArg();\n            else if (m_analyzeCommand.needsPointListArg())\n            {\n                ConstPointList list = m_analyzeCommand.getPointListArg();\n                if (list.size() > 0)\n                    pointArg = list.get(list.size() - 1);\n            }\n            if (type == AnalyzeType.PARAM)\n                ParameterDialog.editParameters(m_lastAnalyzeCommand, this,\n                                               title, response, m_gtp,\n                                               m_messageDialogs);\n            boolean isTextType = m_analyzeCommand.isTextType();\n            String showText = null;\n            if (showTextBuffer.length() > 0)\n                showText = showTextBuffer.toString();\n            else if (isTextType)\n                showText = response;\n            if (showText != null)\n            {\n                if (showText.indexOf(\"\\n\") < 0)\n                {\n                    if (isTextType && showText.trim().equals(\"\"))\n                        showText = i18n(\"STAT_ANALYZE_TEXT_EMPTY_RESPONSE\");\n                    showStatus(format(i18n(\"STAT_ANALYZE_TEXT_RESPONSE\"),\n                                      title, showText));\n                }\n                else\n                {\n                    m_showAnalyzeText.show(type, pointArg, title, showText,\n                                           m_analyzeReuseTextWindow);\n                }\n            }\n            if (\"\".equals(m_statusBar.getText()) && type != AnalyzeType.PARAM)\n                showStatus(title);\n            if (checkComputerMove)\n                checkComputerMove();\n        }\n        catch (GtpResponseFormatError e)\n        {\n            showStatus(title);\n            showError(e);\n        }\n        finally\n        {\n            if (m_analyzeOneRunOnly)\n                clearAnalyzeCommand(false);\n        }\n    }\n\n    private boolean attachNewProgram(String command, Program program)\n    {\n        if (m_gtp != null)\n        {\n            saveSession();\n            detachProgram();\n        }\n        if (! attachProgram(command, program, false))\n        {\n            m_prefs.putInt(\"program\", -1);\n            if (m_gtp == null || m_gtp.isProgramDead())\n                if (! m_shell.isVisible() && m_shell.isLastTextNonGTP())\n                    showShell();\n            updateViews(false);\n            return false;\n        }\n        if (m_shell != null && m_session.isVisible(\"shell\"))\n            m_shell.setVisible(true);\n        if (m_session.isVisible(\"analyze\"))\n            createAnalyzeDialog();\n        toFrontLater();\n        updateViews(false);\n        return true;\n    }\n\n    /** Attach program.\n        @param programCommand Command line for running program.\n        @param program Program information (may be null)\n        @param register Create an entry for this program in the Program menu.\n        @return true if program was successfully attached. */\n    private boolean attachProgram(String programCommand, Program program,\n                                  boolean register)\n    {\n        programCommand = programCommand.trim();\n        if (programCommand.equals(\"\"))\n            return false;\n        m_program = program;\n        m_programCommand = programCommand;\n        if (m_shell != null)\n        {\n            m_shell.dispose();\n            m_shell = null;\n        }\n        m_shell = new GtpShell(this, this, m_messageDialogs);\n        GuiAction.registerAll(m_shell.getLayeredPane());\n        m_shell.addWindowListener(new WindowAdapter() {\n                public void windowClosing(WindowEvent e) {\n                    saveSession();\n                    hideShell();\n                }\n            });\n        restoreSize(m_shell, \"shell\");\n        m_shell.setProgramCommand(programCommand);\n        m_shell.setTimeStamp(m_timeStamp);\n        m_shell.setCommandCompletion(m_commandCompletion);\n        GtpClient.InvalidResponseCallback invalidResponseCallback =\n            new GtpClient.InvalidResponseCallback()\n            {\n                public void show(String line)\n                {\n                    Runnable runnable = new ShowInvalidResponse(line);\n                    if (SwingUtilities.isEventDispatchThread())\n                        runnable.run();\n                    else\n                        GuiUtil.invokeAndWait(runnable);\n                }\n            };\n        GtpClient.IOCallback ioCallback = new GtpClient.IOCallback()\n            {\n                public void receivedInvalidResponse(String s)\n                {\n                    if (m_shell == null)\n                        return;\n                    boolean invokeLater = true;\n                    m_shell.receivedInvalidResponse(s, invokeLater);\n                }\n\n                public void receivedResponse(boolean error, String s)\n                {\n                    if (m_shell == null)\n                        return;\n                    boolean invokeLater = true;\n                    m_shell.receivedResponse(error, s, invokeLater);\n                }\n\n                public void receivedStdErr(String s)\n                {\n                    if (m_shell == null)\n                        return;\n                    m_lineReader.add(s);\n                    while (m_lineReader.hasLines())\n                    {\n                        String line = m_lineReader.getLine();\n                        boolean isLiveGfx = m_liveGfx.handleLine(line);\n                        boolean isWarning =\n                            line.startsWith(\"warning:\")\n                            || line.startsWith(\"Warning:\")\n                            || line.startsWith(\"WARNING:\");\n                        boolean invokeLater = true;\n                        m_shell.receivedStdErr(line, invokeLater, isLiveGfx,\n                                               isWarning);\n                    }\n                }\n\n                public void sentCommand(String s)\n                {\n                    if (m_shell != null)\n                        m_shell.sentCommand(s);\n                }\n\n                private final LineReader m_lineReader = new LineReader();\n\n                private LiveGfx m_liveGfx = new LiveGfx(GoGui.this);\n            };\n        GtpSynchronizer.Listener synchronizerCallback =\n            new GtpSynchronizer.Listener() {\n                public void moveNumberChanged(int moveNumber) {\n                    String text = \"[\" + moveNumber + \"]\";\n                    m_statusBar.immediatelyPaintMoveText(text);\n                }\n            };\n        try\n        {\n            showStatusImmediately(i18n(\"STAT_ATTACHING_PROGRAM\"));\n            File workingDirectory = null;\n            if (program != null\n                && ! StringUtil.isEmpty(program.m_workingDirectory))\n                workingDirectory = new File(program.m_workingDirectory);\n            GtpClient gtp =\n                new GtpClient(m_programCommand, workingDirectory,\n                              m_verbose, ioCallback);\n            gtp.setInvalidResponseCallback(invalidResponseCallback);\n            gtp.setAutoNumber(m_autoNumber);\n            m_gtp = new GuiGtpClient(gtp, this, synchronizerCallback,\n                                     m_messageDialogs);\n            m_gtp.queryName();\n            m_gtp.queryProtocolVersion();\n            try\n            {\n                m_version = m_gtp.queryVersion();\n                m_shell.setProgramVersion(m_version);\n                m_gtp.querySupportedCommands();\n                m_gtp.queryInterruptSupport();\n                if (m_program == null)\n                {\n                    m_program =\n                        Program.findProgram(m_programs, programCommand);\n                    if (m_program == null && m_register)\n                    {\n                        m_program = new Program(\"\", m_gtp.getName(), m_version,\n                                                programCommand, \"\");\n                        m_program.setUniqueLabel(m_programs);\n                        m_programs.add(m_program);\n                        m_menuBar.setPrograms(m_programs);\n                        Program.save(m_programs);\n                    }\n                }\n            }\n            catch (GtpError e)\n            {\n            }\n            if (m_program != null\n                && m_program.updateInfo(getProgramName(), m_version))\n            {\n                Program.save(m_programs);\n                m_menuBar.setPrograms(m_programs);\n            }\n            try\n            {\n                String programAnalyzeCommands\n                    = GtpClientUtil.getAnalyzeCommands(m_gtp);\n                m_analyzeCommands\n                    = AnalyzeDefinition.read(m_gtp.getSupportedCommands(),\n                                             m_analyzeCommandsFile,\n                                             programAnalyzeCommands);\n            }\n            catch (ErrorMessage e)\n            {\n                showError(i18n(\"MSG_COULD_NOT_READ_ANALYZE_CONFIGURATION\"), e);\n            }\n            restoreSize(m_shell, \"shell\");\n            m_shell.setProgramName(getProgramLabel());\n            ArrayList<String> supportedCommands =\n                m_gtp.getSupportedCommands();\n            m_shell.setInitialCompletions(supportedCommands);\n            if (! m_gtp.isGenmoveSupported())\n            {\n                m_computerBlack = false;\n                m_computerWhite = false;\n            }\n            initGtp();\n            if (! m_gtpFile.equals(\"\"))\n                sendGtpFile(new File(m_gtpFile));\n            if (! m_gtpCommand.equals(\"\"))\n                sendGtpString(m_gtpCommand);\n            setTitle();\n        }\n        catch (GtpError e)\n        {\n            showError(e);\n            return false;\n        }\n        finally\n        {\n            clearStatus();\n        }\n        currentNodeChanged();\n        return true;\n    }\n\n    private void beginLengthyCommand()\n    {\n        setBoardCursor(Cursor.WAIT_CURSOR);\n        m_shell.setCommandInProgess(true);\n        showStatus(format(i18n(\"STAT_THINKING\"), getProgramName()));\n        updateViews(false);\n    }\n\n    private void boardChangedBegin(boolean doCheckComputerMove,\n                                   boolean gameTreeChanged)\n    {\n        updateFromGoBoard();\n        updateViews(gameTreeChanged);\n        if (m_analyzeDialog != null)\n            m_analyzeDialog.setSelectedColor(getToMove());\n        if (m_gtp != null\n            && ! isOutOfSync()\n            && m_analyzeCommand != null\n            && m_analyzeAutoRun\n            && ! m_analyzeCommand.isPointArgMissing())\n            analyzeBegin(doCheckComputerMove);\n        else\n        {\n            resetBoard();\n            clearStatus();\n            if (doCheckComputerMove)\n                checkComputerMove();\n        }\n    }\n\n    private boolean checkCommandInProgress()\n    {\n        if (isCommandInProgress())\n        {\n            showError(i18n(\"MSG_CANNOT_EXECUTE_WHILE_THINKING\"),\n                      i18n(\"MSG_CANNOT_EXECUTE_WHILE_THINKING_2\"), false);\n            return false;\n        }\n        return true;\n    }\n\n    private void checkComputerMove()\n    {\n        if (m_gtp == null || isOutOfSync() || m_gtp.isProgramDead())\n            return;\n        int moveNumber = NodeUtil.getMoveNumber(getCurrentNode());\n        boolean bothPassed = (moveNumber >= 2 && getBoard().bothPassed());\n        boolean gameFinished = (bothPassed || m_resigned);\n        if (isComputerBoth())\n        {\n            if (gameFinished)\n            {\n                if (m_auto)\n                {\n                    newGame(getBoardSize());\n                    updateViews(true, true);\n                    checkComputerMove();\n                    return;\n                }\n                m_game.haltClock();\n                showGameFinished();\n                return;\n            }\n            generateMove(false);\n        }\n        else\n        {\n            if (gameFinished)\n            {\n                m_game.haltClock();\n                showGameFinished();\n                return;\n            }\n            else if (computerToMove())\n                generateMove(false);\n        }\n    }\n\n    private boolean checkHasParameterCommands()\n    {\n        if (! AnalyzeUtil.hasParameterCommands(m_analyzeCommands))\n        {\n            String optionalMessage =\n                format(i18n(\"MSG_NO_PARAM_COMMANDS_2\"), getProgramName());\n            showError(i18n(\"MSG_NO_PARAM_COMMANDS\"), optionalMessage);\n            return false;\n        }\n        return true;\n    }\n\n    private void checkLostOnTime(GoColor color)\n    {\n        if (getClock().lostOnTime(color)\n            && ! getClock().lostOnTime(color.otherColor())\n            && ! m_lostOnTimeShown)\n        {\n            String result = color.otherColor().getUppercaseLetter() + \"+Time\";\n            String mainMessage;\n            String optionalMessage;\n            if (color == BLACK)\n            {\n                mainMessage = i18n(\"MSG_LOST_ON_TIME_BLACK\");\n                optionalMessage = format(i18n(\"MSG_LOST_ON_TIME_BLACK_2\"),\n                                         result);\n            }\n            else\n            {\n                mainMessage = i18n(\"MSG_LOST_ON_TIME_WHITE\");\n                optionalMessage = format(i18n(\"MSG_LOST_ON_TIME_WHITE_2\"),\n                                         result);\n            }\n            showInfo(mainMessage, optionalMessage, false);\n            setResult(result);\n            m_lostOnTimeShown = true;\n        }\n    }\n\n    private boolean checkSaveGame()\n    {\n        return checkSaveGame(false);\n    }\n\n    /** Ask for saving file if it was modified.\n        @return true If file was not modified, user chose not to save it\n        or file was saved successfully */\n    private boolean checkSaveGame(boolean isProgramTerminating)\n    {\n        if (! isModified())\n            return true;\n        String mainMessage = i18n(\"MSG_SAVE_CURRENT\");\n        String optionalMessage = i18n(\"MSG_SAVE_CURRENT_2\");\n        int result;\n        String disableKey = null;\n        if (! isProgramTerminating)\n            disableKey = \"net.sf.gogui.gogui.GoGui.save\";\n        result = m_messageDialogs.showYesNoCancelQuestion(disableKey, this,\n                                                          mainMessage,\n                                                          optionalMessage,\n                                                          i18n(\"LB_DONT_SAVE\"),\n                                                          i18n(\"LB_SAVE\"));\n        switch (result)\n        {\n        case 0:\n            m_game.clearModified();\n            return true;\n        case 1:\n            if (m_gameFile == null)\n                return saveDialog();\n            else\n                return save(m_gameFile);\n        case 2:\n            return false;\n        default:\n            assert false;\n            return true;\n        }\n    }\n\n    /** Check if command is in progress or setup or score mode. */\n    private boolean checkStateChangePossible()\n    {\n        if (! checkCommandInProgress())\n            return false;\n        if (m_setupMode)\n            setupDone();\n        if (m_scoreMode)\n            scoreDone(null);\n        return true;\n    }\n\n    private void clearAnalyzeCommand()\n    {\n        clearAnalyzeCommand(true);\n    }\n\n    private void clearAnalyzeCommand(boolean resetBoard)\n    {\n        if (m_analyzeCommand != null)\n        {\n            m_analyzeCommand = null;\n            setBoardCursorDefault();\n        }\n        if (resetBoard)\n        {\n            resetBoard();\n            clearStatus();\n        }\n    }\n\n    private void clearStatus()\n    {\n        m_statusBar.clear();\n    }\n\n    private void close()\n    {\n        if (! checkSaveGame(true))\n            return;\n        saveSession();\n        setVisible(false);\n        SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    if (m_gtp != null)\n                    {\n                        m_analyzeCommand = null;\n                        detachProgram();\n                    }\n                    dispose();\n                    System.exit(0);\n                }\n            });\n    }\n\n    private void computerMoved()\n    {\n        if (! endLengthyCommand())\n            return;\n        if (m_beepAfterMove)\n            Toolkit.getDefaultToolkit().beep();\n        GoColor toMove = getToMove();\n        try\n        {\n            String response = m_gtp.getResponse();\n            checkLostOnTime(toMove);\n            boolean gameTreeChanged = false;\n            String name = getProgramName();\n            if (response.equalsIgnoreCase(\"resign\"))\n            {\n                String result =\n                    toMove.otherColor().getUppercaseLetter() + \"+Resign\";\n                if (! m_auto)\n                {\n                    String mainMessage = format(i18n(\"MSG_RESIGN\"), name);\n                    String optionalMessage =\n                        format(i18n(\"MSG_RESIGN_2\"), result);\n                    showInfo(mainMessage, optionalMessage, false);\n                }\n                m_resigned = true;\n                setResult(result);\n            }\n            else\n            {\n                GoPoint point = GtpUtil.parsePoint(response, getBoardSize());\n                ConstBoard board = getBoard();\n                if (point != null)\n                {\n                    if (board.getColor(point) != EMPTY)\n                    {\n                        String mainMessage =\n                            format(i18n(\"MSG_NONEMPTY\"), name);\n                        String optionalMessage =\n                            format(i18n(\"MSG_NONEMPTY_2\"), name);\n                        showWarning(mainMessage, optionalMessage, true);\n                        m_computerBlack = false;\n                        m_computerWhite = false;\n                    }\n                    else if (board.isKo(point))\n                    {\n                        String mainMessage =\n                            format(i18n(\"MSG_VIOLATE_KO\"), name);\n                        showWarning(mainMessage, i18n(\"MSG_VIOLATE_KO_2\"),\n                                    true);\n                        m_computerBlack = false;\n                        m_computerWhite = false;\n                    }\n                }\n                Move move = Move.get(toMove, point);\n                m_game.play(move);\n                m_gtp.updateAfterGenmove(getBoard());\n                if (point == null && ! isComputerBoth())\n                {\n                    String disableKey =\n                        \"net.sf.gogui.gogui.GoGui.computer-passed\";\n                    String mainMessage =\n                        format(i18n(\"MSG_PROGRAM_PASS\"), name);\n                    String optionalMessage =\n                        format(i18n(\"MSG_PROGRAM_PASS_2\"), name);\n                    m_messageDialogs.showInfo(disableKey, this, mainMessage,\n                                              optionalMessage, false);\n                }\n                m_resigned = false;\n                gameTreeChanged = true;\n                ConstNode currentNode = getCurrentNode();\n                if (currentNode.getFatherConst().getNumberChildren() == 1)\n                {\n                    if (m_gameTreeViewer != null)\n                        m_gameTreeViewer.addNewSingleChild(currentNode);\n                    gameTreeChanged = false;\n                }\n            }\n            boolean doCheckComputerMove\n                = (! m_isSingleMove\n                   && ! (isComputerBoth() && m_interruptComputerBoth));\n            boardChangedBegin(doCheckComputerMove, gameTreeChanged);\n        }\n        catch (GtpResponseFormatError e)\n        {\n            showError(e);\n            clearStatus();\n        }\n    }\n\n    private boolean computerToMove()\n    {\n        if (getToMove() == BLACK)\n            return m_computerBlack;\n        else\n            return m_computerWhite;\n    }\n\n    private void createAnalyzeDialog()\n    {\n        m_analyzeDialog = new AnalyzeDialog(this, this, m_analyzeCommands,\n                                            m_gtp, m_messageDialogs);\n        m_analyzeDialog.setReuseTextWindow(\n                        m_prefs.getBoolean(\"analyze-reuse-text-window\", false));\n        GuiAction.registerAll(m_analyzeDialog.getLayeredPane());\n        m_analyzeDialog.addWindowListener(new WindowAdapter() {\n                public void windowClosing(WindowEvent e) {\n                    actionDisposeAnalyzeDialog();\n                }\n            });\n        m_analyzeDialog.setBoardSize(getBoardSize());\n        m_analyzeDialog.setSelectedColor(getToMove());\n        restoreSize(m_analyzeDialog, \"analyze\");\n        m_analyzeDialog.setVisible(true);\n    }\n\n    private ContextMenu createContextMenu(GoPoint point)\n    {\n        boolean noProgram = (m_gtp == null);\n        return new ContextMenu(point, m_guiBoard.getMark(point),\n                               m_guiBoard.getMarkCircle(point),\n                               m_guiBoard.getMarkSquare(point),\n                               m_guiBoard.getMarkTriangle(point),\n                               this);\n    }\n\n    private void createTree()\n    {\n        m_gameTreeViewer = new GameTreeViewer(this, this, m_messageDialogs);\n        m_gameTreeViewer.addWindowListener(new WindowAdapter() {\n                public void windowClosing(WindowEvent e) {\n                    actionDisposeTree();\n                }\n            });\n        GuiAction.registerAll(m_gameTreeViewer.getLayeredPane());\n        m_gameTreeViewer.setLabelMode(m_treeLabels);\n        m_gameTreeViewer.setSizeMode(m_treeSize);\n        m_gameTreeViewer.setShowSubtreeSizes(m_showSubtreeSizes);\n        restoreSize(m_gameTreeViewer, \"tree\");\n        m_gameTreeViewer.update(getTree(), getCurrentNode());\n        m_gameTreeViewer.setVisible(true);\n    }\n\n    private void createThumbnail(File file)\n    {\n        if (! ThumbnailPlatform.checkThumbnailSupport())\n            return;\n        String path = file.getAbsolutePath();\n        if (! path.startsWith(\"/tmp\") && ! path.startsWith(\"/var/tmp\"))\n        {\n            try\n            {\n                m_thumbnailCreator.create(file);\n            }\n            catch (ErrorMessage e)\n            {\n            }\n        }\n    }\n\n    private void currentNodeChanged()\n    {\n        updateFromGoBoard();\n    }\n\n    private void detachProgram()\n    {\n        if (m_gtp != null)\n            showStatusImmediately(i18n(\"STAT_DETACHING\"));\n        if (isCommandInProgress())\n        {\n            m_gtp.destroyGtp();\n            m_gtp.close();\n        }\n        else\n        {\n            if (m_gtp != null && ! m_gtp.isProgramDead())\n            {\n                // Some programs do not handle closing the GTP stream\n                // correctly, so we send a quit before\n                try\n                {\n                    if (m_gtp.isSupported(\"quit\"))\n                        m_gtp.send(\"quit\");\n                }\n                catch (GtpError e)\n                {\n                }\n                m_gtp.close();\n            }\n        }\n        m_gtp = null;\n        if (m_analyzeCommand != null)\n            clearAnalyzeCommand();\n        m_version = null;\n        m_shell.dispose();\n        m_shell = null;\n        if (m_analyzeDialog != null)\n        {\n            m_analyzeDialog.saveRecent();\n            m_analyzeDialog.dispose();\n            m_analyzeDialog = null;\n        }\n        resetBoard();\n        clearStatus();\n        setTitle();\n    }\n\n    private boolean endLengthyCommand()\n    {\n        return endLengthyCommand(true, true);\n    }\n\n    private boolean endLengthyCommand(boolean isCritical)\n    {\n        return endLengthyCommand(isCritical, true);\n    }\n\n    private boolean endLengthyCommand(boolean isCritical,\n                                      boolean showError)\n    {\n        restoreBoardCursor();\n        clearStatus();\n        if (m_shell != null)\n            m_shell.setCommandInProgess(false);\n        // Program could have been killed in actionDetachProgram()\n        if (m_gtp == null)\n            return false;\n        GtpError error = m_gtp.getException();\n        updateViews(false);\n        if (error != null && showError)\n        {\n            showError(error, isCritical);\n            return false;\n        }\n        return true;\n    }\n\n    private String formatCommand(String command)\n    {\n        if (command.length() < 20)\n            return command;\n        GtpCommand cmd = new GtpCommand(command);\n        return cmd.getCommand() + \" [...]\";\n    }\n\n    private void generateMove(boolean isSingleMove)\n    {\n        if (! synchronizeProgram())\n            return;\n        GoColor toMove = getToMove();\n        ConstNode node = getCurrentNode();\n        ConstNode father = node.getFatherConst();\n        ConstGameInfo info = getGameInfo();\n        String playerToMove = info.get(StringInfoColor.NAME, toMove);\n        String playerOther =\n            info.get(StringInfoColor.NAME, toMove.otherColor());\n        String name = getProgramLabel();\n        if (! isSingleMove && m_gameFile == null && playerToMove == null\n            && (father == null\n                || (! father.hasFather()\n                    && (playerOther == null || playerOther.equals(name)))))\n        {\n            m_game.setPlayer(toMove, name);\n            updateViews(false);\n        }\n        String command;\n        if (NodeUtil.isInCleanup(getCurrentNode())\n            && m_gtp.isSupported(\"kgs-genmove_cleanup\"))\n        {\n            command = \"kgs-genmove_cleanup\";\n            if (toMove == BLACK)\n                command += \" b\";\n            else if (toMove == WHITE)\n                command += \" w\";\n            else\n                assert false;\n        }\n        else\n        {\n            command = m_gtp.getCommandGenmove(toMove);\n        }\n        m_isSingleMove = isSingleMove;\n        m_interruptComputerBoth = false;\n        Runnable callback = new Runnable()\n            {\n                public void run()\n                {\n                    computerMoved();\n                }\n            };\n        if (getClock().isInitialized()\n            && NodeUtil.isTimeLeftKnown(getCurrentNode(), toMove))\n            GtpUtil.sendTimeLeft(m_gtp, getClock(), toMove);\n        m_game.startClock();\n        runLengthyCommand(command, callback);\n    }\n\n    private ConstBoard getBoard()\n    {\n        return m_game.getBoard();\n    }\n\n    private int getBoardSize()\n    {\n        return m_game.getSize();\n    }\n\n    private ConstClock getClock()\n    {\n        return m_game.getClock();\n    }\n\n    private ConstNode getCurrentNode()\n    {\n        return m_game.getCurrentNode();\n    }\n\n    private ConstGameInfo getGameInfo()\n    {\n        return m_game.getGameInfo(getCurrentNode());\n    }\n\n    private Komi getPrefsKomi()\n    {\n        try\n        {\n            String s = m_prefs.get(\"komi\", \"6.5\");\n            return Komi.parseKomi(s);\n        }\n        catch (InvalidKomiException e)\n        {\n            return null;\n        }\n    }\n\n    private GoColor getToMove()\n    {\n        return m_game.getToMove();\n    }\n\n    private ConstGameTree getTree()\n    {\n        return m_game.getTree();\n    }\n\n    /** Change current node.\n        Automatically restores the clock, or halts it, if no time settings\n        are known. */\n    private void gotoNode(ConstNode node)\n    {\n        // GameTreeViewer is not disabled in score mode\n        if (m_scoreMode)\n            return;\n        m_game.gotoNode(node);\n        if (getClock().isInitialized())\n            m_game.restoreClock();\n        else\n            m_game.haltClock();\n        currentNodeChanged();\n    }\n\n    private void hideShell()\n    {\n        if (m_shell == null)\n            return;\n        saveSession();\n        m_shell.setVisible(false);\n    }\n\n    private void humanMoved(Move move)\n    {\n        GoPoint p = move.getPoint();\n        if (p != null)\n            paintImmediately(p, move.getColor(), true);\n        if (m_gtp != null && ! isComputerNone() && ! isOutOfSync()\n            && ! m_gtp.isProgramDead())\n        {\n            synchronizeProgram();\n            try\n            {\n                m_gtp.updateHumanMove(getBoard(), move);\n            }\n            catch (GtpError e)\n            {\n                showError(e);\n                boardChangedBegin(false, false);\n                return;\n            }\n        }\n        boolean newNodeCreated = false;\n        ConstNode node = NodeUtil.getChildWithMove(getCurrentNode(), move);\n        if (node == null)\n        {\n            newNodeCreated = true;\n            m_game.play(move);\n        }\n        else\n        {\n            m_game.haltClock();\n            m_game.gotoNode(node);\n        }\n        checkLostOnTime(move.getColor());\n        m_resigned = false;\n        boolean gameTreeChanged = newNodeCreated;\n        ConstNode currentNode = getCurrentNode();\n        if (newNodeCreated\n            && currentNode.getFatherConst().getNumberChildren() == 1)\n        {\n            if (m_gameTreeViewer != null)\n                m_gameTreeViewer.addNewSingleChild(currentNode);\n            gameTreeChanged = false;\n        }\n        boardChangedBegin(true, gameTreeChanged);\n    }\n\n    private void importTextPosition(Reader reader)\n    {\n        try\n        {\n            TextParser parser = new TextParser();\n            parser.parse(reader);\n            GameTree tree =\n                NodeUtil.makeTreeFromPosition(null, parser.getBoard());\n            m_game.init(tree);\n        }\n        catch (ParseError e)\n        {\n            showError(i18n(\"MSG_IMPORT_FAILED\"), e);\n        }\n        m_guiBoard.initSize(getBoard().getSize());\n        initGtp();\n        m_computerBlack = false;\n        m_computerWhite = false;\n        boardChangedBegin(false, true);\n    }\n\n    private void initGame(int size)\n    {\n        int oldSize = getBoardSize();\n        if (size != oldSize)\n        {\n            // Clear analyze command when board size changes, because eplist\n            // could contain points out of board)\n            clearAnalyzeCommand();\n            saveSession();\n            m_guiBoard.initSize(size);\n            restoreMainWindow(size);\n            JLayeredPane layeredPane = getLayeredPane();\n            if (layeredPane.isVisible())\n            {\n                // Loading a file with program attached can take long\n                GuiUtil.paintImmediately(layeredPane);\n            }\n        }\n        Komi komi = (m_handicap == 0 ? getPrefsKomi() : new Komi(0));\n        ConstPointList handicap = Board.getHandicapStones(size, m_handicap);\n        if (handicap == null)\n            showWarning(i18n(\"MSG_HANDICAP_UNDEFINED\"),\n                        format(i18n(\"MSG_HANDICAP_UNDEFINED_2\"), m_handicap,\n                               size), false);\n        m_game.init(size, komi, handicap, m_prefs.get(\"rules\", \"\"),\n                    m_timeSettings);\n        if (size != oldSize)\n        {\n            if (m_shell != null)\n                restoreSize(m_shell, \"shell\");\n            if (m_analyzeDialog != null)\n            {\n                restoreSize(m_analyzeDialog, \"analyze\");\n                m_analyzeDialog.setBoardSize(size);\n            }\n            if (m_gameTreeViewer != null)\n                restoreSize(m_gameTreeViewer, \"tree\");\n        }\n        updateFromGoBoard();\n        resetBoard();\n        m_game.resetClock();\n        m_lostOnTimeShown = false;\n        m_resigned = false;\n        m_pattern = null;\n    }\n\n    private boolean initGtp()\n    {\n        if (m_gtp != null)\n        {\n            try\n            {\n                ConstGameInfo info = getGameInfo();\n                m_gtp.initSynchronize(getBoard(), info.getKomi(),\n                                      info.getTimeSettings());\n            }\n            catch (GtpError error)\n            {\n                showError(error);\n                return false;\n            }\n        }\n        currentNodeChanged();\n        return ! isOutOfSync();\n    }\n\n    private void initialize()\n    {\n        m_guiBoard.setListener(this);\n        m_guiBoard.addMouseWheelListener(new MouseWheelListener() {\n                public void mouseWheelMoved(MouseWheelEvent e) {\n                    // Silently ignore mouse wheel events if command in\n                    // progress because it is easy to generate multiple events\n                    // while using the wheel and if an analyze command is\n                    // enabled to automatically run after each board change,\n                    // actionForward() and actionBackward() would pop up an\n                    // error dialog if the analyze command is still in progress\n                    if (isCommandInProgress())\n                        return;\n                    int n = e.getWheelRotation();\n                    int mod = e.getModifiers();\n                    int scale = (mod == ActionEvent.SHIFT_MASK ? 10 : 1);\n                    if (n > 0)\n                        actionForward(scale * n);\n                    else\n                        actionBackward(-scale * n);\n                }\n            });\n\n        GuiUtil.removeKeyBinding(m_splitPane, \"F8\");\n        GuiAction.registerAll(getLayeredPane());\n\n        m_bookmarks = Bookmark.load();\n        m_menuBar.setBookmarks(m_bookmarks);\n        m_programs = Program.load();\n        m_menuBar.setPrograms(m_programs);\n        if (m_programCommand == null)\n        {\n            int index = m_prefs.getInt(\"program\", -1);\n            if (index >= 0 && index < m_programs.size())\n            {\n                m_program = m_programs.get(index);\n                m_programCommand = m_program.m_command;\n            }\n        }\n        if (m_initialFile == null)\n            newGame(getBoardSize());\n        else\n            newGameFile(getBoardSize(), m_move);\n        if (! m_prefs.getBoolean(\"show-info-panel\", true))\n            showInfoPanel(false);\n        if (m_prefs.getBoolean(\"show-toolbar\", true))\n            showToolbar(true);\n        restoreMainWindow(getBoardSize());\n        // Attaching a program can take some time, so we want to make\n        // the window visible, but not draw the window content yet\n        getLayeredPane().setVisible(false);\n        setVisible(true);\n        if (m_programCommand != null)\n        {\n            attachProgram(m_programCommand, m_program, m_register);\n            if (m_gtp == null || m_gtp.isProgramDead())\n                m_prefs.putInt(\"program\", -1);\n        }\n        setTitle();\n        registerSpecialMacHandler();\n        // Children dialogs should be set visible after main window, otherwise\n        // they get minimize window buttons and a taskbar entry (KDE 3.4)\n        if (m_shell != null && m_session.isVisible(\"shell\"))\n            m_shell.setVisible(true);\n        if (m_session.isVisible(\"tree\"))\n            createTree();\n        if (m_gtp != null && m_session.isVisible(\"analyze\"))\n            createAnalyzeDialog();\n        setTitleFromProgram();\n        updateViews(true);\n        getLayeredPane().setVisible(true);\n        unprotectGui();\n        toFrontLater();\n        checkComputerMove();\n    }\n\n    private void initScore(ConstPointList deadStones)\n    {\n        resetBoard();\n        GuiBoardUtil.scoreBegin(m_guiBoard, m_countScore, getBoard(),\n                                deadStones);\n        m_scoreMode = true;\n        if (m_scoreDialog == null)\n        {\n            ScoringMethod scoringMethod = getGameInfo().parseRules();\n            m_scoreDialog = new ScoreDialog(this, this, scoringMethod);\n        }\n        restoreLocation(m_scoreDialog, \"score\");\n        Komi komi = getGameInfo().getKomi();\n        m_scoreDialog.showScore(m_countScore, komi);\n        m_scoreDialog.setVisible(true);\n        showStatus(i18n(\"STAT_SCORE\"));\n    }\n\n    private boolean isComputerBoth()\n    {\n        return (m_computerBlack && m_computerWhite);\n    }\n\n    private boolean isComputerNone()\n    {\n        return ! (m_computerBlack || m_computerWhite);\n    }\n\n    private boolean isOutOfSync()\n    {\n        return (m_gtp != null && m_gtp.isOutOfSync());\n    }\n\n    private boolean loadFile(File file, int move)\n    {\n        try\n        {\n            LoadFileRunnable runnable = new LoadFileRunnable(file);\n            if (file.length() > 500000)\n            {\n                newGame(getBoardSize()); // Frees space if already large tree\n                GuiUtil.runProgress(this, i18n(\"LB_LOADING\"), runnable);\n            }\n            else\n                runnable.run(null);\n            GameTree tree = runnable.getTree();\n            initGame(tree.getBoardSize());\n            m_menuBar.addRecent(file);\n            m_game.init(tree);\n            initGtp();\n            if (move > 0)\n            {\n                ConstNode node =\n                    NodeUtil.findByMoveNumber(getCurrentNode(), move);\n                if (node != null)\n                    m_game.gotoNode(node);\n            }\n            setFile(runnable.getGameFile());\n            FileDialogs.setLastFile(file);\n            String warnings = runnable.getWarnings();\n            if (warnings != null)\n            {\n                String optionalMessage =\n                    i18n(\"MSG_FILE_FORMAT_WARNING_2\")\n                    + \"\\n(\" +\n                    warnings.replaceAll(\"\\n\\\\z\", \"\").replaceAll(\"\\n\", \")\\n(\")\n                    + \")\";\n                showWarning(i18n(\"MSG_FILE_FORMAT_WARNING\"), optionalMessage,\n                            true);\n            }\n            m_computerBlack = false;\n            m_computerWhite = false;\n            createThumbnail(file);\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_FILE_NOT_FOUND\"), e);\n            return false;\n        }\n        catch (SgfError e)\n        {\n            showError(i18n(\"MSG_COULD_NOT_READ_FILE\"), e);\n            return false;\n        }\n        catch (ErrorMessage e)\n        {\n            showError(i18n(\"MSG_COULD_NOT_READ_FILE\"), e);\n            return false;\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace();\n            assert false;\n            return false;\n        }\n        return true;\n    }\n\n    private void newGame(int size)\n    {\n        initGame(size);\n        initGtp();\n        updateFromGoBoard();\n        setTitle();\n        setTitleFromProgram();\n        clearStatus();\n    }\n\n    private void newGameFile(int size, int move)\n    {\n        initGame(size);\n        if (! loadFile(m_initialFile, move))\n            m_gameFile = null;\n    }\n\n    /** Paint point immediately to pretend better responsiveness.\n        Necessary because waiting for a repaint of the Go board can be slow\n        due to the updating game tree or response to GTP commands. */\n    private void paintImmediately(GoPoint point, GoColor color, boolean isMove)\n    {\n        m_guiBoard.setColor(point, color);\n        if (isMove && m_showLastMove)\n            m_guiBoard.markLastMove(point);\n        m_guiBoard.paintImmediately(point);\n    }\n\n    private void protectGui()\n    {\n        getGlassPane().setVisible(true);\n        setCursor(getGlassPane(), Cursor.WAIT_CURSOR);\n    }\n\n    private void registerSpecialMacHandler()\n    {\n        if (! Platform.isMac())\n            return;\n        Platform.SpecialMacHandler handler = new Platform.SpecialMacHandler()\n            {\n                public boolean handleAbout()\n                {\n                    assert SwingUtilities.isEventDispatchThread();\n                    actionAbout();\n                    return true;\n                }\n\n                public boolean handleOpenFile(String filename)\n                {\n                    assert SwingUtilities.isEventDispatchThread();\n                    if (! checkSaveGame())\n                        return true;\n                    loadFile(new File(filename), -1);\n                    boardChangedBegin(false, true);\n                    return true;\n                }\n\n                public boolean handleQuit()\n                {\n                    assert SwingUtilities.isEventDispatchThread();\n                    close();\n                    // close() calls System.exit() if not cancelled\n                    return false;\n                }\n            };\n        Platform.registerSpecialMacHandler(handler);\n    }\n\n    private void resetBoard()\n    {\n        clearStatus();\n        m_guiBoard.clearAll();\n        updateFromGoBoard();\n        updateGuiBoard();\n    }\n\n    private void restoreBoardCursor()\n    {\n        if (m_analyzeCommand != null\n            && (m_analyzeCommand.needsPointArg()\n                || m_analyzeCommand.needsPointListArg()))\n            setBoardCursor(Cursor.HAND_CURSOR);\n        else\n            setBoardCursorDefault();\n    }\n\n    private void restoreLocation(JDialog dialog, String name)\n    {\n        m_session.restoreLocation(dialog, this, name + \"-\" + getBoardSize());\n    }\n\n    private void restoreMainWindow(int size)\n    {\n        setState(Frame.NORMAL);\n        m_session.restoreLocation(this, \"main-\" + size);\n        String path = \"windows/main/size-\" + size + \"/fieldsize\";\n        int fieldSize = m_prefs.getInt(path, -1);\n        if (fieldSize > 0)\n            m_guiBoard.setPreferredFieldSize(new Dimension(fieldSize,\n                                                           fieldSize));\n        path = \"windows/main/size-\" + size + \"/comment\";\n        int width = m_prefs.getInt(path + \"/width\", -1);\n        int height = m_prefs.getInt(path + \"/height\", -1);\n        Dimension preferredCommentSize = null;\n        if (width > 0 && height > 0)\n        {\n            preferredCommentSize = new Dimension(width, height);\n            m_comment.setPreferredSize(preferredCommentSize);\n        }\n        else\n            m_comment.setPreferredSize();\n        m_splitPane.resetToPreferredSizes();\n        pack();\n        // To avoid smallish empty borders (less than one field size) on top\n        // and bottom borders of the board we adjust the comment size slightly\n        // if necessary\n        if (m_infoPanel.getHeight() - m_guiBoard.getHeight() < 2 * fieldSize\n            && preferredCommentSize != null && fieldSize > 0)\n        {\n            preferredCommentSize.height -= 2 * fieldSize;\n            m_comment.setPreferredSize(preferredCommentSize);\n            m_splitPane.resetToPreferredSizes();\n            pack();\n        }\n    }\n\n    private void restoreSize(JDialog dialog, String name)\n    {\n        m_session.restoreSize(dialog, this, name + \"-\" + getBoardSize());\n    }\n\n    private void runLengthyCommand(String cmd, Runnable callback)\n    {\n        assert m_gtp != null;\n        m_gtp.send(cmd, callback);\n        beginLengthyCommand();\n    }\n\n    /** Save game to file.\n        @return true If successfully saved. */\n    private boolean save(GameFile gameFile)\n    {\n        try\n        {\n            new GameWriter(gameFile, getTree(), i18n(\"LB_GOGUI\"),\n                           Version.get());\n        }\n        catch (ErrorMessage e)\n        {\n            showError(i18n(\"MSG_SAVING_FAILED\"), e);\n            return false;\n        }\n        m_menuBar.addRecent(gameFile.m_file);\n        createThumbnail(gameFile.m_file);\n        setFile(gameFile);\n        m_game.clearModified();\n        updateViews(false);\n        return true;\n    }\n\n    private boolean saveDialog()\n    {\n        File file = FileDialogs.showSaveSgf(this, m_messageDialogs);\n        if (file == null)\n            return false;\n        GameFile gameFile = new GameFile();\n        gameFile.m_file = file;\n        if (FileUtil.hasExtension(file, \"xml\"))\n            gameFile.m_format = GameFile.Format.XML;\n        else\n            gameFile.m_format = GameFile.Format.SGF;\n        return save(gameFile);\n    }\n\n    private boolean saveParameters(File file)\n    {\n        try\n        {\n            GtpClientUtil.saveParameters(m_gtp, m_analyzeCommands, file);\n        }\n        catch (ErrorMessage e)\n        {\n            showError(i18n(\"MSG_COULD_NOT_SAVE_PARAMETERS\"), e);\n            return false;\n        }\n        return true;\n    }\n\n    private void savePosition(File file) throws FileNotFoundException\n    {\n        OutputStream out = new FileOutputStream(file);\n        new SgfWriter(out, getBoard(), i18n(\"LB_GOGUI\"), Version.get());\n        m_menuBar.addRecent(file);\n        updateViews(false);\n    }\n\n    private void saveSession()\n    {\n        if (m_shell != null)\n            m_shell.saveHistory();\n        if (m_analyzeDialog != null)\n        {\n            m_analyzeDialog.saveRecent();\n            m_prefs.putBoolean(\"analyze-reuse-text-window\",\n                               m_analyzeDialog.getReuseTextWindow());\n        }\n        if (! isVisible()) // can that happen?\n            return;\n        if (m_help != null)\n            m_session.saveSize(m_help.getWindow(), \"help\");\n        saveSizeAndVisible(m_gameTreeViewer, \"tree\");\n        if (m_gtp != null)\n        {\n            saveSizeAndVisible(m_shell, \"shell\");\n            saveSizeAndVisible(m_analyzeDialog, \"analyze\");\n        }\n        m_session.saveLocation(this, \"main-\" + getBoardSize());\n        if (GuiUtil.isNormalSizeMode(this))\n        {\n            String name = \"windows/main/size-\" + getBoardSize() + \"/fieldsize\";\n            int fieldSize = m_guiBoard.getFieldSize().width;\n            if (fieldSize == 0) // BoardPainter was never invoked\n                return;\n            m_prefs.putInt(name, fieldSize);\n            name = \"windows/main/size-\" + getBoardSize() + \"/comment/width\";\n            m_prefs.putInt(name, m_comment.getWidth());\n            name = \"windows/main/size-\" + getBoardSize() + \"/comment/height\";\n            m_prefs.putInt(name, m_comment.getHeight());\n        }\n        // GoGui's program logic does currently not depend on syncing the\n        // preferences to disk immediately, but we do it anyway to work around\n        // a bug in OpenJDK 1.6.0_20 on Linux (Ubuntu 10.10), which fails to\n        // perform the automatic syncing of class Preferences on shutdown of\n        // the VM (probably because of a BadWindow X Error on window closing)\n        try\n        {\n            m_prefs.sync();\n        }\n        catch (BackingStoreException e)\n        {\n            System.err.println(e.getMessage());\n        }\n    }\n\n    private void saveLocation(JDialog dialog, String name)\n    {\n        m_session.saveLocation(dialog, this, name + \"-\" + getBoardSize());\n    }\n\n    private void saveSizeAndVisible(JDialog dialog, String name)\n    {\n        int size = getBoardSize();\n        if (dialog != null)\n            m_session.saveSize(dialog, this, name + \"-\" + size);\n        m_session.saveVisible(dialog, name);\n    }\n\n    private void scoreContinue()\n    {\n        boolean success = endLengthyCommand();\n        clearStatus();\n        PointList isDeadStone = null;\n        if (success)\n        {\n            String response = m_gtp.getResponse();\n            try\n            {\n                isDeadStone\n                    = GtpUtil.parsePointList(response, getBoardSize());\n            }\n            catch (GtpResponseFormatError e)\n            {\n                showError(e);\n            }\n        }\n        updateViews(false);\n        initScore(isDeadStone);\n    }\n\n    private void scoreDone(Score score)\n    {\n        if (! m_scoreMode)\n            return;\n        m_scoreMode = false;\n        saveLocation(m_scoreDialog, \"score\");\n        m_scoreDialog.setVisible(false);\n        clearStatus();\n        m_guiBoard.clearAll();\n        if (score != null)\n            setResult(score.formatResult());\n    }\n\n    private void sendGtp(Reader reader)\n    {\n        if (m_gtp == null)\n            return;\n        java.io.BufferedReader in;\n        in = new BufferedReader(reader);\n        try\n        {\n            while (true)\n            {\n                try\n                {\n                    String line = in.readLine();\n                    if (line == null)\n                        break;\n                    if (! GtpUtil.isCommand(line))\n                        continue;\n                    if (GtpUtil.isStateChangingCommand(line))\n                    {\n                        showError(i18n(\"MSG_BOARD_CHANGING_COMMAND\"), \"\");\n                        break;\n                    }\n                    try\n                    {\n                        m_gtp.send(line);\n                    }\n                    catch (GtpError e)\n                    {\n                        showError(e);\n                        if (m_gtp.isProgramDead()\n                            || ! showQuestion(i18n(\"MSG_CONTINUE_SEND\"), \"\",\n                                              i18n(\"LB_CONTINUE_SEND\"), false))\n                            break;\n                    }\n                }\n                catch (IOException e)\n                {\n                    showError(i18n(\"MSG_COULD_NOT_READ_FILE\"), e);\n                    break;\n                }\n            }\n        }\n        finally\n        {\n            try\n            {\n                in.close();\n            }\n            catch (IOException e)\n            {\n            }\n        }\n    }\n\n    private void sendGtpFile(File file)\n    {\n        try\n        {\n            sendGtp(new FileReader(file));\n        }\n        catch (FileNotFoundException e)\n        {\n            showError(i18n(\"MSG_FILE_NOT_FOUND\"), e);\n        }\n    }\n\n    private void sendGtpString(String commands)\n    {\n        commands = commands.replaceAll(\"\\\\\\\\n\", \"\\n\");\n        sendGtp(new StringReader(commands));\n    }\n\n    private void setBoardCursor(int type)\n    {\n        setCursor(m_guiBoard, type);\n    }\n\n    private void setBoardCursorDefault()\n    {\n        setCursorDefault(m_guiBoard);\n    }\n\n    private void setCursor(Component component, int type)\n    {\n        Cursor cursor = Cursor.getPredefinedCursor(type);\n        component.setCursor(cursor);\n    }\n\n    private void setCursorDefault(Component component)\n    {\n        component.setCursor(Cursor.getDefaultCursor());\n    }\n\n    private void setFile(GameFile gameFile)\n    {\n        m_gameFile = gameFile;\n        setTitle();\n    }\n\n    private void setMinimumSize()\n    {\n        int width = 128;\n        int height = 32;\n        Insets rootInsets = getRootPane().getInsets();\n        int rootInsetsWidth = rootInsets.left + rootInsets.right;\n        Dimension menuBarSize = getJMenuBar().getPreferredSize();\n        width = Math.max(width, (int)menuBarSize.getWidth() + rootInsetsWidth);\n        height = Math.max(height, (int)menuBarSize.getHeight());\n        if (m_showToolbar)\n        {\n            Insets contentInsets = getContentPane().getInsets();\n            int contentInsetsWidth = contentInsets.left + contentInsets.right;\n            Dimension toolBarSize = m_toolBar.getPreferredSize();\n            width = Math.max(width,\n                             (int)toolBarSize.getWidth() + rootInsetsWidth\n                             + contentInsetsWidth + GuiUtil.PAD);\n            height += (int)toolBarSize.getHeight();\n        }\n        height += 224;\n        setMinimumSize(new Dimension(width, height));\n    }\n\n    private void setResult(String result)\n    {\n        String oldResult = getGameInfo().get(StringInfo.RESULT);\n        if (! (oldResult == null || oldResult.equals(\"\")\n               || oldResult.equals(result))\n            && ! showQuestion(format(i18n(\"MSG_REPLACE_RESULT\"), oldResult,\n                                     result),\n                              i18n(\"MSG_REPLACE_RESULT_2\"),\n                              i18n(\"LB_REPLACE_RESULT\"), false))\n            return;\n        m_game.setResult(result);\n    }\n\n    private void setTitle()\n    {\n        if (m_titleFromProgram != null)\n        {\n            setTitle(m_titleFromProgram);\n            return;\n        }\n        String appName = i18n(\"LB_GOGUI\");\n        if (m_gtp != null)\n            appName = getProgramLabel();\n        String filename = null;\n        if (m_gameFile != null)\n        {\n            filename = m_gameFile.m_file.getName();\n            // On the Mac, a modified document is indicated by setting the\n            // windowModified property in updateViews()\n            if (isModified() && ! Platform.isMac())\n                filename = filename + \"*\";\n        }\n        ConstGameInfo info = getGameInfo();\n        String gameName = info.suggestGameName();\n        if (gameName != null)\n        {\n            if (filename != null)\n                gameName = filename + \"  \" + gameName;\n        }\n        else if (filename != null)\n            gameName = filename;\n        if (gameName == null)\n            setTitle(appName);\n        else\n        {\n            String name = getProgramLabel();\n            String nameBlack = info.get(StringInfoColor.NAME, BLACK);\n            String nameWhite = info.get(StringInfoColor.NAME, WHITE);\n            if (! appName.equals(i18n(\"LB_GOGUI\"))\n                && (ObjectUtil.equals(nameBlack, name)\n                    || ObjectUtil.equals(nameWhite, name)))\n                setTitle(gameName);\n            else\n                setTitle(gameName + \" - \" + appName);\n        }\n    }\n\n    private void setTitleFromProgram()\n    {\n        if (m_gtp == null)\n            m_titleFromProgram = null;\n        else\n            m_titleFromProgram = GtpClientUtil.getTitle(m_gtp);\n        if (m_titleFromProgram != null)\n            setTitle(m_titleFromProgram);\n    }\n\n    private void setup(GoPoint point, GoColor color)\n    {\n        assert point != null;\n        m_game.setup(point, color);\n    }\n\n    private void setupDone()\n    {\n        if (! m_setupMode)\n            return;\n        m_setupMode = false;\n        ConstNode currentNode = getCurrentNode();\n        if (currentNode.hasSetup() || m_setupColor != getToMove())\n            m_game.setToMove(m_setupColor);\n        else if (m_setupNodeCreated && currentNode.isEmpty()\n                 && currentNode.hasFather())\n            m_game.truncate();\n        currentNodeChanged();\n    }\n\n    private void showError(String message, Exception e)\n    {\n        showError(message, e, true);\n    }\n\n    private void showError(String message, Exception e, boolean isCritical)\n    {\n        m_messageDialogs.showError(this, message, e, isCritical);\n    }\n\n    private void showError(GtpError error)\n    {\n        showError(error, true);\n    }\n\n    private void showError(GtpResponseFormatError e)\n    {\n        String name = getProgramName();\n        String mainMessage = format(i18n(\"MSG_INVALID_RESPONSE\"), name);\n        String optionalMessage =\n            format(i18n(\"MSG_INVALID_RESPONSE_2\"), name, e.getMessage());\n        showError(mainMessage, optionalMessage, true);\n    }\n\n    private void showError(GtpError e, boolean isCritical)\n    {\n        String name = getProgramName();\n        String mainMessage;\n        String optionalMessage;\n        if (m_gtp != null && m_gtp.isProgramDead())\n        {\n            if (m_gtp.wasKilled())\n                mainMessage = format(i18n(\"MSG_PROGRAM_TERMINATED\"), name);\n            else\n                mainMessage = i18n(\"MSG_PROGRAM_TERMINATED_UNEXPECTEDLY\");\n            boolean hasErrorOutput = m_shell.isLastTextNonGTP();\n            boolean anyResponses = m_gtp.getAnyCommandsResponded();\n            if (hasErrorOutput && ! anyResponses)\n                optionalMessage =\n                    format(i18n(\"MSG_PROGRAM_TERMINATED_2\"), name);\n            else if (hasErrorOutput && anyResponses)\n                optionalMessage =\n                    format(i18n(\"MSG_PROGRAM_TERMINATED_3\"), name);\n            else\n                optionalMessage = i18n(\"MSG_PROGRAM_TERMINATED_4\");\n        }\n        else if (e instanceof GtpClient.ExecFailed)\n        {\n            mainMessage = i18n(\"MSG_COULD_NOT_EXECUTE\");\n            if (StringUtil.isEmpty(e.getMessage()))\n                optionalMessage = i18n(\"MSG_COULD_NOT_EXECUTE_2\");\n            else\n                optionalMessage =\n                    format(i18n(\"MSG_COULD_NOT_EXECUTE_3\"), e.getMessage());\n        }\n        else\n        {\n            mainMessage = i18n(\"MSG_COMMAND_FAILED\");\n            if (e.getMessage().trim().equals(\"\"))\n                optionalMessage =\n                    format(i18n(\"MSG_COMMAND_FAILED_2\"), e.getCommand());\n            else\n                optionalMessage =\n                    format(i18n(\"MSG_COMMAND_FAILED_3\"), e.getCommand(),\n                           e.getMessage());\n        }\n        showError(mainMessage, optionalMessage, isCritical);\n        updateViews(false); // If program died, menu items need to be updated\n    }\n\n    private void showError(String mainMessage, String optionalMessage)\n    {\n        showError(mainMessage, optionalMessage, true);\n    }\n\n    private void showError(String mainMessage, String optionalMessage,\n                           boolean isCritical)\n    {\n        m_messageDialogs.showError(this, mainMessage, optionalMessage,\n                                   isCritical);\n    }\n\n    private void showGameFinished()\n    {\n        if (m_resigned)\n            return;\n        String disableKey = \"net.sf.gogui.gogui.GoGui.game-finished\";\n        m_messageDialogs.showInfo(disableKey, this,\n                                  i18n(\"MSG_GAME_FINISHED\"),\n                                  i18n(\"MSG_GAME_FINISHED_2\"), false);\n    }\n\n    private void showInfo(String mainMessage, String optionalMessage,\n                          boolean isCritical)\n    {\n        m_messageDialogs.showInfo(this, mainMessage, optionalMessage,\n                                  isCritical);\n    }\n\n    private void showInfoPanel(boolean enable)\n    {\n        if (enable == m_showInfoPanel)\n            return;\n        m_prefs.putBoolean(\"show-info-panel\", enable);\n        m_showInfoPanel = enable;\n        if (enable)\n        {\n            m_innerPanel.remove(m_guiBoard);\n            m_splitPane.add(m_guiBoard);\n            m_innerPanel.add(m_splitPane);\n        }\n        else\n        {\n            m_splitPane.remove(m_guiBoard);\n            m_innerPanel.remove(m_splitPane);\n            m_innerPanel.add(m_guiBoard);\n        }\n        m_splitPane.resetToPreferredSizes();\n        pack();\n    }\n\n    private boolean showOptionalQuestion(String id, String mainMessage,\n                                         String optionalMessage,\n                                         String destructiveOption,\n                                         boolean isCritical)\n    {\n        String disableKey = \"net.sf.gogui.gogui.GoGui\" + id;\n        return m_messageDialogs.showQuestion(disableKey, this, mainMessage,\n                                             optionalMessage,\n                                             destructiveOption, isCritical);\n    }\n\n    private boolean showQuestion(String mainMessage, String optionalMessage,\n                                 String destructiveOption, boolean isCritical)\n    {\n        return m_messageDialogs.showQuestion(this, mainMessage,\n                                             optionalMessage,\n                                             destructiveOption, isCritical);\n    }\n\n    private File showSave(String title)\n    {\n        return FileDialogs.showSave(this, title, m_messageDialogs);\n    }\n\n    private void showShell()\n    {\n        if (m_gtp == null)\n            return;\n        if (m_shell.isVisible())\n            m_shell.toFront();\n        else\n        {\n            restoreSize(m_shell, \"shell\");\n            m_shell.setVisible(true);\n        }\n    }\n\n    private void showStatus(String text)\n    {\n        m_statusBar.setText(text);\n    }\n\n    private void showStatusImmediately(String text)\n    {\n        m_statusBar.immediatelyPaintText(text);\n    }\n\n    private void showStatusSelectPointList()\n    {\n        showStatus(format(i18n(\"STAT_SELECT_POINTLIST\"),\n                          m_analyzeCommand.getLabel()));\n    }\n\n    private void showStatusSelectTarget()\n    {\n        showStatus(format(i18n(\"STAT_SELECT_TARGET\"),\n                          m_analyzeCommand.getResultTitle()));\n    }\n\n    private void showToolbar(boolean enable)\n    {\n        if (enable == m_showToolbar)\n            return;\n        m_prefs.putBoolean(\"show-toolbar\", enable);\n        m_showToolbar = enable;\n        if (enable)\n            getContentPane().add(m_toolBar, BorderLayout.NORTH);\n        else\n            getContentPane().remove(m_toolBar);\n        m_splitPane.resetToPreferredSizes();\n        setMinimumSize();\n        pack();\n    }\n\n    private void showWarning(String mainMessage, String optionalMessage,\n                             boolean isCritical)\n    {\n        m_messageDialogs.showWarning(this, mainMessage, optionalMessage,\n                                     isCritical);\n    }\n\n    private boolean synchronizeProgram()\n    {\n        if (m_gtp == null)\n        {\n            showError(i18n(\"MSG_NO_PROGRAM_ATTACHED\"), \"\", false);\n            return false;\n        }\n        if (! checkCommandInProgress())\n            return false;\n        String name = getProgramName();\n        if (m_gtp.isProgramDead())\n        {\n            String mainMessage = format(i18n(\"MSG_PROGRAM_TERMINATED\"), name);\n            String optionalMessage = \"\";\n            if (m_shell.isLastTextNonGTP())\n            {\n                showShell();\n                optionalMessage =\n                    format(i18n(\"MSG_PROGRAM_TERMINATED_CHECK_GTP\"), name);\n            }\n            else\n            {\n                showShell();\n                optionalMessage =\n                    format(i18n(\"MSG_PROGRAM_TERMINATED_REATTACH\"), name);\n            }\n            showError(mainMessage, optionalMessage, false);\n            // If program died, menu items need to be updated\n            updateViews(false);\n            return false;\n        }\n        boolean wasOutOfSync = isOutOfSync();\n        try\n        {\n            ConstGameInfo info = getGameInfo();\n            m_gtp.synchronize(getBoard(), info.getKomi(),\n                              info.getTimeSettings());\n        }\n        catch (GtpError e)\n        {\n            if (wasOutOfSync)\n            {\n                String mainMessage = format(i18n(\"MSG_OUT_OF_SYNC\"), name);\n                String optionalMessage = format(i18n(\"MSG_OUT_OF_SYNC_2\"),\n                                                name);\n                showError(mainMessage, optionalMessage, false);\n            }\n            else\n            {\n                String mainMessage = format(i18n(\"MSG_NOSYNC\"), name);\n                String command = null;\n                if (e.getCommand() != null)\n                    command = formatCommand(e.getCommand());\n                String message = e.getMessage();\n                String response = null;\n                if (! message.trim().equals(\"\"))\n                    response = message;\n                String optionalMessage;\n                if (command == null)\n                    optionalMessage =\n                        format(i18n(\"MSG_NOSYNC_ERROR\"), name, message);\n                else if (response == null)\n                    optionalMessage =\n                        format(i18n(\"MSG_NOSYNC_FAILURE\"),\n                               command, name);\n                else\n                    optionalMessage =\n                        format(i18n(\"MSG_NOSYNC_FAILURE_RESPONSE\"),\n                               command, name, response);\n                showWarning(mainMessage, optionalMessage, true);\n                // If the program died, menu items need to be updated\n                updateViews(false);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private void toFrontLater()\n    {\n        // Calling toFront() directly does not give the focus to this\n        // frame, if dialogs are open\n        SwingUtilities.invokeLater(new Runnable() {\n                public void run()\n                {\n                    requestFocus();\n                    toFront();\n                }\n            });\n    }\n\n    private void unprotectGui()\n    {\n        getGlassPane().setVisible(false);\n        setCursor(getGlassPane(), Cursor.DEFAULT_CURSOR);\n    }\n\n    private void updateViews(boolean gameTreeChanged)\n    {\n        updateViews(gameTreeChanged, false);\n    }\n\n    /** Update all views.\n        @param gameTreeChanged If nodes were added to or removed from the game\n        tree, which will trigger a full and potentially slow game tree update\n        @param sync Update game tree within the event handler if the gameTree\n        has changed. */\n    private void updateViews(boolean gameTreeChanged, boolean sync)\n    {\n        m_actions.update();\n        m_menuBar.update(isProgramAttached(), isTreeShown(), isShellShown());\n        m_gameInfoPanel.update();\n        m_comment.setComment(getCurrentNode().getComment());\n        updateFromGoBoard();\n        updateGuiBoard();\n        getRootPane().putClientProperty(\"windowModified\",\n                                        Boolean.valueOf(isModified()));\n        setTitle();\n        GoGuiUtil.updateMoveText(m_statusBar, getGame());\n        m_statusBar.setSetupMode(m_setupMode);\n        if (m_setupMode)\n            m_statusBar.setToPlay(m_setupColor);\n        if (m_gameTreeViewer != null)\n        {\n            if (gameTreeChanged)\n            {\n                if (sync)\n                    m_gameTreeViewer.update(getTree(), getCurrentNode());\n                else\n                {\n                    protectGui();\n                    showStatus(i18n(\"STAT_UPDATING_TREE\"));\n                    Runnable runnable = new Runnable() {\n                            public void run() {\n                                try\n                                {\n                                    m_gameTreeViewer.update(getTree(),\n                                                            getCurrentNode());\n                                }\n                                finally\n                                {\n                                    unprotectGui();\n                                    clearStatus();\n                                }\n                            }\n                        };\n                    SwingUtilities.invokeLater(runnable);\n                }\n            }\n            else\n                m_gameTreeViewer.update(getCurrentNode());\n        }\n    }\n\n    private void updateFromGoBoard()\n    {\n        boolean showLastMove =\n            (m_showLastMove\n             && ! (m_showVariations == ShowVariations.SIBLINGS\n                   && NodeUtil.hasSiblingMoves(getCurrentNode())));\n        GuiBoardUtil.updateFromGoBoard(m_guiBoard, getBoard(), m_showLastMove,\n                                       m_showMoveNumbers);\n        if (! showLastMove || getCurrentNode().getMove() == null)\n            m_guiBoard.markLastMove(null);\n    }\n\n    private void updateGuiBoard()\n    {\n        if (m_showVariations == ShowVariations.CHILDREN)\n        {\n            ConstPointList moves = NodeUtil.getChildrenMoves(getCurrentNode());\n            GuiBoardUtil.showMoves(m_guiBoard, moves);\n        }\n        else if (m_showVariations == ShowVariations.SIBLINGS\n                 && NodeUtil.hasSiblingMoves(getCurrentNode()))\n        {\n            ConstNode father = getCurrentNode().getFatherConst();\n            if (father != null)\n            {\n                ConstPointList moves = NodeUtil.getChildrenMoves(father);\n                if (moves.size() > 1)\n                    GuiBoardUtil.showMoves(m_guiBoard, moves);\n            }\n        }\n        GuiBoardUtil.showMarkup(m_guiBoard, getCurrentNode());\n    }\n}\n",
			"GTP",
			"GTPVERSION",
			"gtp",
			"fix",
			"\\label",
			"fig_mistake",
			"fig_fifo",
			"o",
			"1.617",
			"log_thre",
			"LOG",
			"print()",
			"TOTAL",
			"pq",
			"24",
			"input_db",
			"filename",
			"recor",
			"lookup_table",
			"(\"%\")",
			"is_goal",
			"board",
			"evaluate",
			"memcpy",
			"memcmp",
			"operator",
			"stack",
			"	\n",
			"))",
			"gen_board",
			"init_",
			"user_mem_abort",
			"冠位",
			"kvm_inject_dabt",
			"TTBR",
			"inject_",
			"decode_hsr",
			"guest_abort",
			"kvm_vcpu_trap_get_class",
			"get_exit_handler",
			"hvc",
			"trace",
			"kvm_run",
			" \n",
			"Socratis",
			"kvm_inject_undefined",
			"verify",
			"ESR",
			"CPTR",
			"cp15_32",
			"matrix_mul.brig",
			"check",
			"DumpZero",
			"kvm_arch_vcpu_runnalble",
			"KVM_RUN",
			"put_cpu",
			"put_cput",
			"kvm_arch_vcpu_load",
			"vcpu_load",
			"kvm_run",
			"EINVAL",
			"kvm_vcpu",
			"vcpu",
			"__attribute__",
			"__section",
			"Image"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"rms",
			"Socrates",
			"+\"",
			"\"+",
			"print",
			"checkbox",
			"title",
			"Response",
			"calendar",
			"lambda",
			"microseconds",
			"value",
			"<br /><textarea name=\"comments\" style=\"margin: 0px; width: 898px; height: 148px;\">Enter text here.</textarea>",
			"<br /><textarea name=\"comments\" style=\"margin: 0px; width: 898px; height: 148px;\">Enter text here.</textarea></div>",
			"<br /><textarea name=\"comments\">Enter text here.</textarea>",
			"<textarea name=\"comments\">Enter text here.</textarea>",
			"",
			"Edge",
			"ROUND",
			"\\begin{figure}[H]",
			"\\begin{figure}[h]",
			"\\begin{figure}[h!]",
			"",
			"GET",
			"<{if $teacher}>\n	<td><button type=\"submit\" class=\"btn btn-primary\">Assign Grades</button></td>\n	<{/if}>",
			"aaa",
			"alpha",
			"beta",
			"False",
			"True",
			"oursystem",
			"",
			"0.1",
			"console",
			"//console.log"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 229.0
	},
	"output.sftp":
	{
		"height": 112.0
	},
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 291.0,
	"status_bar_visible": true
}
